//> link: -lraylib -lm

import "raylib.h" as rl;
import "rlgl.h";
import "math.h";

// Import our modules
import "blocks.zc";
import "lighting.zc";
import "chunk.zc";
import "chunk_mesh.zc";
import "raycast.zc";
import "rendering.zc";
import "player.zc";

fn main() {
    rl::InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, TITLE);
    rl::SetWindowState(rl::FLAG_WINDOW_RESIZABLE);
    defer { rl::CloseWindow(); }

    rl::SetTargetFPS(60);

    // Load Assets
    init_textures();

    // Initialize Player
    let p = Player::new(10.0, 10.0, 10.0);
    let selected_block = BLOCK_STONE;

    // Generate Chunks
    // Buffer size: MAX_CHUNKS
    let chunks: Chunk*;
    raw {
        chunks = (Chunk*)MemAlloc(sizeof(Chunk) * MAX_CHUNKS);
    }
    
    // Initialize empty chunks
    for i in 0..MAX_CHUNKS {
        chunks[i].x = -9999;
        chunks[i].z = -9999;
    }

    rl::DisableCursor(); // Capture mouse
    
    // Track previous position to avoid unnecessary updates
    let last_pcx = -99999;
    let last_pcz = -99999;

    while !rl::WindowShouldClose() {
        let dt: float = rl::GetFrameTime();
        
        // --- CHUNK UPDATE LOGIC ---
        let pcx = (int)floor(p.x / 16.0);
        let pcz = (int)floor(p.z / 16.0);
        
        // Full update loop
        // Zen-C ranges are exclusive of the upper bound, so we go to RENDER_DISTANCE + 1
        let range_limit = RENDER_DISTANCE + 1;
        for dx in -RENDER_DISTANCE..range_limit {
             for dz in -RENDER_DISTANCE..range_limit {
                 let cx = pcx + dx;
                 let cz = pcz + dz;
                 let idx = get_chunk_index(cx, cz);
                 
                 if chunks[idx].x != cx || chunks[idx].z != cz {
                     chunks[idx] = Chunk::new(cx, cz);
                     // Propagate light for gradual lighting
                     propagate_light_in_chunk(&chunks[idx], &chunks[0], MAX_CHUNKS);
                     
                     // We need to build the mesh. 
                     // Also, neighbors might need rebuilding if we appeared next to them.
                     // For simplicity, just build self now. Neighbors will update eventually or we force them.
                     chunks[idx].mesh_dirty = 1;
                 }
             }
        }
        
        (&p).update(&chunks[0], MAX_CHUNKS, dt);

        // Block selection input
        if rl::IsKeyPressed(rl::KEY_ONE) { selected_block = BLOCK_DIRT; }
        if rl::IsKeyPressed(rl::KEY_TWO) { selected_block = BLOCK_GRASS; }
        if rl::IsKeyPressed(rl::KEY_THREE) { selected_block = BLOCK_STONE; }
        if rl::IsKeyPressed(rl::KEY_FOUR) { selected_block = BLOCK_LOG; }
        if rl::IsKeyPressed(rl::KEY_FIVE) { selected_block = BLOCK_LEAVES; }

        rl::BeginDrawing();
        // Sky blue background
        rl::ClearBackground(rl::Color{r: 135, g: 206, b: 235, a: 255});

        draw_sky(p.camera);

        rl::BeginMode3D(p.camera);
        
        // Disable back-face culling to see all faces
        raw {
            rlDisableBackfaceCulling();
        }

        // Render visible chunks
        // We can just iterate the buffer, or iterate the view radius for Frustum Culling later
        for i in 0..MAX_CHUNKS {
            let c: Chunk* = &chunks[i];
            // Simple frustum/distance check could go here
             // Only draw if valid
            if c.x != -9999 {
                c.draw(&chunks[0], MAX_CHUNKS);
            }
        }

        // Block interaction
        let screen_center = rl::Vector2{
            x: (float)rl::GetScreenWidth() / 2.0,
            y: (float)rl::GetScreenHeight() / 2.0
        };
        let pick_ray = rl::GetScreenToWorldRay(screen_center, p.camera);

        let hit = raycast(&chunks[0], MAX_CHUNKS, pick_ray.position.x, pick_ray.position.y, pick_ray.position.z, 
                          pick_ray.direction.x, pick_ray.direction.y, pick_ray.direction.z, 5.0);

        if hit.hit != 0 {
            // Draw selection
            let hx = (float)hit.x;
            let hy = (float)hit.y;
            let hz = (float)hit.z;

            // Draw slight offset wireframe
            rl::DrawCubeWires(rl::Vector3{x: hx + 0.5, y: hy + 0.5, z: hz + 0.5}, 1.01, 1.01, 1.01, rl::BLACK);

            // Input handling
            if rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_LEFT) {
                set_block(&chunks[0], MAX_CHUNKS, hit.x, hit.y, hit.z, BLOCK_AIR);
                update_sunlight_column(&chunks[0], MAX_CHUNKS, hit.x, hit.z);
                
                // Rebuild the chunk modified
                let cx = (int)floor((float)hit.x / 16.0);
                let cz = (int)floor((float)hit.z / 16.0);
                let idx = get_chunk_index(cx, cz);
                
                // Propagate light in this chunk and neighbors
                propagate_light_in_chunk(&chunks[idx], &chunks[0], MAX_CHUNKS);
                
                chunks[idx].mesh_dirty = 1;
                
                // Update neighbor chunks if block was at edge
                let lx = ((hit.x % 16) + 16) % 16;
                let lz = ((hit.z % 16) + 16) % 16;
                
                if lx == 0 {
                    let idx_west = get_chunk_index(cx - 1, cz);
                    if chunks[idx_west].x == (cx - 1) && chunks[idx_west].z == cz {
                        chunks[idx_west].mesh_dirty = 1;
                    }
                }
                if lx == 15 {
                    let idx_east = get_chunk_index(cx + 1, cz);
                    if chunks[idx_east].x == (cx + 1) && chunks[idx_east].z == cz {
                        chunks[idx_east].mesh_dirty = 1;
                    }
                }
                if lz == 0 {
                    let idx_south = get_chunk_index(cx, cz - 1);
                    if chunks[idx_south].x == cx && chunks[idx_south].z == (cz - 1) {
                        chunks[idx_south].mesh_dirty = 1;
                    }
                }
                if lz == 15 {
                    let idx_north = get_chunk_index(cx, cz + 1);
                    if chunks[idx_north].x == cx && chunks[idx_north].z == (cz + 1) {
                        chunks[idx_north].mesh_dirty = 1;
                    }
                }
            }
            else if rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_RIGHT) {
                let nx = hit.x + hit.face_x;
                let ny = hit.y + hit.face_y;
                let nz = hit.z + hit.face_z;

                // Don't place inside player (Simple check)
                let dist_x = p.x - ((float)nx + 0.5);
                let dist_y = p.y + 1.6 - ((float)ny + 0.5); // Eye pos vs block center
                let dist_z = p.z - ((float)nz + 0.5);
                if (dist_x*dist_x + dist_y*dist_y + dist_z*dist_z) > 2.0 {
                     set_block(&chunks[0], MAX_CHUNKS, nx, ny, nz, selected_block);
                     update_sunlight_column(&chunks[0], MAX_CHUNKS, nx, nz);
                     
                     let cx = (int)floor((float)nx / 16.0);
                     let cz = (int)floor((float)nz / 16.0);
                     let idx = get_chunk_index(cx, cz);
                     
                     // Propagate light in this chunk and neighbors
                     propagate_light_in_chunk(&chunks[idx], &chunks[0], MAX_CHUNKS);
                     
                     chunks[idx].mesh_dirty = 1;
                     
                     // Update neighbor chunks if block was at edge
                     let lx = ((nx % 16) + 16) % 16;
                     let lz = ((nz % 16) + 16) % 16;
                     
                     if lx == 0 {
                         let idx_west = get_chunk_index(cx - 1, cz);
                         if chunks[idx_west].x == (cx - 1) && chunks[idx_west].z == cz {
                             chunks[idx_west].mesh_dirty = 1;
                         }
                     }
                     if lx == 15 {
                         let idx_east = get_chunk_index(cx + 1, cz);
                         if chunks[idx_east].x == (cx + 1) && chunks[idx_east].z == cz {
                             chunks[idx_east].mesh_dirty = 1;
                         }
                     }
                     if lz == 0 {
                         let idx_south = get_chunk_index(cx, cz - 1);
                         if chunks[idx_south].x == cx && chunks[idx_south].z == (cz - 1) {
                             chunks[idx_south].mesh_dirty = 1;
                         }
                     }
                     if lz == 15 {
                         let idx_north = get_chunk_index(cx, cz + 1);
                         if chunks[idx_north].x == cx && chunks[idx_north].z == (cz + 1) {
                             chunks[idx_north].mesh_dirty = 1;
                         }
                     }
                }
            }
        }

        rl::EndMode3D();

        // Draw HUD
        let sw = rl::GetScreenWidth();
        let sh = rl::GetScreenHeight();
        rl::DrawRectangle(sw/2 - 5, sh/2 - 1, 10, 2, rl::RED); // Horizontal
        rl::DrawRectangle(sw/2 - 1, sh/2 - 5, 2, 10, rl::RED); // Vertical

        rl::DrawText("Zen Craft - Infinite Procedural", 10, 10, 20, rl::DARKGRAY);
        rl::DrawText("WASD+Mouse: Move | Click: Break/Place", 10, 30, 20, rl::DARKGRAY);
        rl::DrawText(rl::TextFormat("Selected Block: %d", selected_block), 10, 50, 20, rl::BLACK);
        
        if selected_block == BLOCK_DIRT { rl::DrawText("DIRT", 180, 50, 20, rl::BROWN); }
        else if selected_block == BLOCK_GRASS { rl::DrawText("GRASS", 180, 50, 20, rl::GREEN); }
        else if selected_block == BLOCK_STONE { rl::DrawText("STONE", 180, 50, 20, rl::GRAY); }
        else if selected_block == BLOCK_LOG { rl::DrawText("LOG", 180, 50, 20, rl::GetColor(0x8B4513FF)); }
        else if selected_block == BLOCK_LEAVES { rl::DrawText("LEAVES", 180, 50, 20, rl::DARKGREEN); }

        rl::DrawFPS(10, 100);

        rl::EndDrawing();
    }
}

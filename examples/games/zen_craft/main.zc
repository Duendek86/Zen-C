//> link: -lraylib -lm

import "raylib.h" as rl;
import "rlgl.h";
import "math.h";

// Import our modules
import "blocks.zc";
import "lighting.zc";
import "chunk.zc";
import "chunk_mesh.zc";
import "raycast.zc";
import "rendering.zc";
import "player.zc";
import "persistence.zc";

fn main() {
    rl::InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, TITLE);
    rl::SetWindowState(rl::FLAG_WINDOW_RESIZABLE);
    defer { rl::CloseWindow(); }

    rl::SetTargetFPS(60);

    // Load Assets
    init_textures();
    init_persistence();

    // Initialize Player
    let start_x: float = 10.0;
    let start_y: float = 10.0;
    let start_z: float = 10.0;
    let selected_block = BLOCK_STONE;
    
    // Attempt to load saved state
    if (load_player_data(&start_x, &start_y, &start_z, &selected_block) != 0) {
        start_y += 0.5; // Add safety offset to prevent spawning inside ground
    }
    
    let p = Player::new(start_x, start_y, start_z);

    // Generate Chunks
    // Buffer size: MAX_CHUNKS
    let chunks: Chunk*;
    raw {
        chunks = (Chunk*)MemAlloc(sizeof(Chunk) * MAX_CHUNKS);
    }
    
    // Initialize empty chunks
    for i in 0..MAX_CHUNKS {
        chunks[i].x = -9999;
        chunks[i].z = -9999;
    }

    rl::DisableCursor(); // Capture mouse
    
    // Track previous position to avoid unnecessary updates
    let last_pcx = -99999;
    let last_pcz = -99999;

    while !rl::WindowShouldClose() {
        let dt: float = rl::GetFrameTime();
        
        // --- CHUNK UPDATE LOGIC ---
        let pcx = (int)floor(p.x / 16.0);
        let pcz = (int)floor(p.z / 16.0);
        
        // Full update loop
        // Zen-C ranges are exclusive of the upper bound, so we go to RENDER_DISTANCE + 1
        let range_limit = RENDER_DISTANCE + 1;
        for dx in -RENDER_DISTANCE..range_limit {
             for dz in -RENDER_DISTANCE..range_limit {
                 let cx = pcx + dx;
                 let cz = pcz + dz;
                 let idx = get_chunk_index(cx, cz);
                 
                 if chunks[idx].x != cx || chunks[idx].z != cz {
                     // If we are already pending loading this coordinate, skip
                     // We can check if chunks[idx].blocks[0][0][0] == -1 as a flag or similar?
                     // Or check if x == -9999 but we just requested?
                     // Actually, chunks[idx].x is currently OLD chunk x.
                     
                     // 1. Save old
                     if chunks[idx].x != -9999 {
                         request_save_async(&chunks[idx]);
                         chunks[idx].x = -9999; // Mark invalid so we don't save again
                     }
                     
                     // 2. Request Load of NEW
                     // We set x to target cx? No, if we do that, we might think it's loaded.
                     // But we need to know we requested it.
                     // Let's set chunks[idx].x = -8888 (Loading State) or use a separate tracker?
                     // If we don't track, we will spam requests every frame.
                     // Simple hack: set x = cx, z = cz, but mark mesh_built = 0?
                     // No, if we set x=cx, then (chunks[idx].x != cx) is false, and we stop requesting. Correct.
                     // BUT, the data isn't there yet.
                     // So we set x=cx, z=cz. The drawing loop checks mesh_built.
                     // But we must make sure we don't draw garbage.
                     // We should clear the block data or set a flag `mesh_built = 0`.
                     // `poll_async_results` will eventually fill the data and set mesh_dirty.
                     
                     chunks[idx].x = cx;
                     chunks[idx].z = cz;
                     chunks[idx].mesh_built = 0; // Don't draw yet
                     chunks[idx].light[0][0][0] = -1; // Flag as not ready? 
                     
                     // Clear blocks to AIR to avoid ghosting if we draw
                     // memset?
                     raw { memset(chunks[idx].blocks, 0, sizeof(chunks[idx].blocks)); }
                     
                     request_load_async(idx, cx, cz);
                 }
             }
        }
        
        (&p).update(&chunks[0], MAX_CHUNKS, dt);
        
        // Poll for async loads finishing
        poll_async_results(&chunks[0], MAX_CHUNKS);

        // Block selection input
        if rl::IsKeyPressed(rl::KEY_ONE) { selected_block = BLOCK_DIRT; }
        if rl::IsKeyPressed(rl::KEY_TWO) { selected_block = BLOCK_GRASS; }
        if rl::IsKeyPressed(rl::KEY_THREE) { selected_block = BLOCK_STONE; }
        if rl::IsKeyPressed(rl::KEY_FOUR) { selected_block = BLOCK_LOG; }
        if rl::IsKeyPressed(rl::KEY_FIVE) { selected_block = BLOCK_LEAVES; }

        rl::BeginDrawing();
        // Sky blue background
        rl::ClearBackground(rl::Color{r: 135, g: 206, b: 235, a: 255});

        draw_sky(p.camera);

        rl::BeginMode3D(p.camera);
        
        // Disable back-face culling to see all faces
        raw {
            rlDisableBackfaceCulling();
        }

        // Render visible chunks
        // We can just iterate the buffer, or iterate the view radius for Frustum Culling later
        let builds_in_frame = 0;
        let max_builds = 1; 

        for i in 0..MAX_CHUNKS {
            let c: Chunk* = &chunks[i];
            // Simple frustum/distance check could go here
             // Only draw if valid
            if c.x != -9999 {
                c.draw(&chunks[0], MAX_CHUNKS, &builds_in_frame, max_builds);
            }
        }

        // Block interaction
        let screen_center = rl::Vector2{
            x: (float)rl::GetScreenWidth() / 2.0,
            y: (float)rl::GetScreenHeight() / 2.0
        };
        let pick_ray = rl::GetScreenToWorldRay(screen_center, p.camera);

        let hit = raycast(&chunks[0], MAX_CHUNKS, pick_ray.position.x, pick_ray.position.y, pick_ray.position.z, 
                          pick_ray.direction.x, pick_ray.direction.y, pick_ray.direction.z, 5.0);

        if hit.hit != 0 {
            // Draw selection
            let hx = (float)hit.x;
            let hy = (float)hit.y;
            let hz = (float)hit.z;

            // Draw slight offset wireframe
            rl::DrawCubeWires(rl::Vector3{x: hx + 0.5, y: hy + 0.5, z: hz + 0.5}, 1.01, 1.01, 1.01, rl::BLACK);

            // Input handling
            if rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_LEFT) {
                set_block(&chunks[0], MAX_CHUNKS, hit.x, hit.y, hit.z, BLOCK_AIR);
                update_sunlight_column(&chunks[0], MAX_CHUNKS, hit.x, hit.z);
                
                // Rebuild the chunk modified
                let cx = (int)floor((float)hit.x / 16.0);
                let cz = (int)floor((float)hit.z / 16.0);
                let idx = get_chunk_index(cx, cz);
                
                // Propagate light in this chunk and neighbors
                propagate_light_in_chunk(&chunks[idx], &chunks[0], MAX_CHUNKS);
                
                chunks[idx].mesh_dirty = 1;
                
                // Update neighbor chunks if block was at edge
                let lx = ((hit.x % 16) + 16) % 16;
                let lz = ((hit.z % 16) + 16) % 16;
                
                if lx == 0 {
                    let idx_west = get_chunk_index(cx - 1, cz);
                    if chunks[idx_west].x == (cx - 1) && chunks[idx_west].z == cz {
                        chunks[idx_west].mesh_dirty = 1;
                    }
                }
                if lx == 15 {
                    let idx_east = get_chunk_index(cx + 1, cz);
                    if chunks[idx_east].x == (cx + 1) && chunks[idx_east].z == cz {
                        chunks[idx_east].mesh_dirty = 1;
                    }
                }
                if lz == 0 {
                    let idx_south = get_chunk_index(cx, cz - 1);
                    if chunks[idx_south].x == cx && chunks[idx_south].z == (cz - 1) {
                        chunks[idx_south].mesh_dirty = 1;
                    }
                }
                if lz == 15 {
                    let idx_north = get_chunk_index(cx, cz + 1);
                    if chunks[idx_north].x == cx && chunks[idx_north].z == (cz + 1) {
                        chunks[idx_north].mesh_dirty = 1;
                    }
                }
            }
            else if rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_RIGHT) {
                let nx = hit.x + hit.face_x;
                let ny = hit.y + hit.face_y;
                let nz = hit.z + hit.face_z;

                // Don't place inside player (Simple check)
                let dist_x = p.x - ((float)nx + 0.5);
                let dist_y = p.y + 1.6 - ((float)ny + 0.5); // Eye pos vs block center
                let dist_z = p.z - ((float)nz + 0.5);
                if (dist_x*dist_x + dist_y*dist_y + dist_z*dist_z) > 2.0 {
                     set_block(&chunks[0], MAX_CHUNKS, nx, ny, nz, selected_block);
                     update_sunlight_column(&chunks[0], MAX_CHUNKS, nx, nz);
                     
                     let cx = (int)floor((float)nx / 16.0);
                     let cz = (int)floor((float)nz / 16.0);
                     let idx = get_chunk_index(cx, cz);
                     
                     // Propagate light in this chunk and neighbors
                     propagate_light_in_chunk(&chunks[idx], &chunks[0], MAX_CHUNKS);
                     
                     chunks[idx].mesh_dirty = 1;
                     
                     // Update neighbor chunks if block was at edge
                     let lx = ((nx % 16) + 16) % 16;
                     let lz = ((nz % 16) + 16) % 16;
                     
                     if lx == 0 {
                         let idx_west = get_chunk_index(cx - 1, cz);
                         if chunks[idx_west].x == (cx - 1) && chunks[idx_west].z == cz {
                             chunks[idx_west].mesh_dirty = 1;
                         }
                     }
                     if lx == 15 {
                         let idx_east = get_chunk_index(cx + 1, cz);
                         if chunks[idx_east].x == (cx + 1) && chunks[idx_east].z == cz {
                             chunks[idx_east].mesh_dirty = 1;
                         }
                     }
                     if lz == 0 {
                         let idx_south = get_chunk_index(cx, cz - 1);
                         if chunks[idx_south].x == cx && chunks[idx_south].z == (cz - 1) {
                             chunks[idx_south].mesh_dirty = 1;
                         }
                     }
                     if lz == 15 {
                         let idx_north = get_chunk_index(cx, cz + 1);
                         if chunks[idx_north].x == cx && chunks[idx_north].z == (cz + 1) {
                             chunks[idx_north].mesh_dirty = 1;
                         }
                     }
                }
            }
        }

        rl::EndMode3D();

        // Draw HUD
        let sw = rl::GetScreenWidth();
        let sh = rl::GetScreenHeight();
        rl::DrawRectangle(sw/2 - 5, sh/2 - 1, 10, 2, rl::RED); // Horizontal
        rl::DrawRectangle(sw/2 - 1, sh/2 - 5, 2, 10, rl::RED); // Vertical

        rl::DrawText("Zen Craft - Infinite Procedural", 10, 10, 20, rl::DARKGRAY);
        rl::DrawText("WASD+Mouse: Move | Click: Break/Place", 10, 30, 20, rl::DARKGRAY);
        rl::DrawText(rl::TextFormat("Selected Block: %d", selected_block), 10, 50, 20, rl::BLACK);
        
        // --- Added: Player Coordinates ---
        rl::DrawText(rl::TextFormat("Pos: %.1f, %.1f, %.1f", p.x, p.y, p.z), 10, 75, 20, rl::BLACK);
        
        if selected_block == BLOCK_DIRT { rl::DrawText("DIRT", 180, 50, 20, rl::BROWN); }
        else if selected_block == BLOCK_GRASS { rl::DrawText("GRASS", 180, 50, 20, rl::GREEN); }
        else if selected_block == BLOCK_STONE { rl::DrawText("STONE", 180, 50, 20, rl::GRAY); }
        else if selected_block == BLOCK_LOG { rl::DrawText("LOG", 180, 50, 20, rl::GetColor(0x8B4513FF)); }
        else if selected_block == BLOCK_LEAVES { rl::DrawText("LEAVES", 180, 50, 20, rl::DARKGREEN); }

        rl::DrawFPS(10, 100);

        rl::EndDrawing();
    }
    
    // Save all loaded chunks on exit
    // Trigger async saves (OS will likely flush buffers on exit or we should wait?)
    // For simplicity, we just trigger them. Ideally we wait for queue empty.
    for i in 0..MAX_CHUNKS {
        if chunks[i].x != -9999 {
            request_save_async(&chunks[i]);
        }
    }
    
    // Save Player Data
    save_player_data(p.x, p.y, p.z, selected_block);
    
    // Small sleep to allow thread to process some? 
    // Or we just expect the OS/Thread to finish. 
    // C process exit kills threads. 
    // We should really wait.
    raw {
        #if defined(_WIN32)
        Sleep(100);
        #else
        usleep(100000);
        #endif
    }
}

//> link: -lraylib -lm

import "raylib.h" as rl;
import "rlgl.h";
import "math.h";

// Import our modules
import "blocks.zc";
import "lighting.zc";
import "chunk.zc";
import "chunk_mesh.zc";
import "raycast.zc";
import "rendering.zc";
import "player.zc";
import "persistence.zc";
import "title_generator.zc";

def STATE_TITLE = 0;
def STATE_GAME = 1;

fn main() {
    rl::InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, TITLE);
    rl::SetWindowState(rl::FLAG_WINDOW_RESIZABLE);
    defer { rl::CloseWindow(); }

    rl::SetTargetFPS(60);

    // Load Assets
    init_textures();
    init_persistence();

    // Loop Variables
    let current_state = STATE_TITLE;
    
    // --- TITLE STATE SETUP ---
    set_game_world_dir("titleworld");
    let title_cam = rl::Camera3D{
        position: rl::Vector3{x: 8.0, y: 15.0, z: 25.0}, // Positive Z looking back at 0
        target: rl::Vector3{x: 8.0, y: 12.0, z: 0.0},
        up: rl::Vector3{x: 0.0, y: 1.0, z: 0.0},
        fovy: 50.0, // Slight zoom in
        projection: rl::CAMERA_PERSPECTIVE
    };

    // --- GAME STATE SETUP ---
    let p: Player;
    let selected_block = BLOCK_STONE;
    let chunks: Chunk*;
    raw {
        chunks = (Chunk*)MemAlloc(sizeof(Chunk) * MAX_CHUNKS);
    }
    
    // Cleanup on exit
    // defer { raw { MemFree(chunks); } } // defer raw not fully supported?

    // Initialize empty chunks
    for i in 0..MAX_CHUNKS {
        chunks[i].x = -9999;
        chunks[i].z = -9999;
    }

    rl::DisableCursor(); // Capture mouse

    while !rl::WindowShouldClose() {
        let dt: float = rl::GetFrameTime();
        
        // --- TITLE SCREEN LOOP ---
        if current_state == STATE_TITLE {
            // Logic
            if rl::IsKeyPressed(rl::KEY_ENTER) {
                // TRANSITION TO GAME
                current_state = STATE_GAME;
                
                // 1. Clear title chunks
                for i in 0..MAX_CHUNKS {
                    chunks[i].x = -9999;
                    chunks[i].z = -9999;
                    chunks[i].mesh_built = 0;
                }
                
                // 2. Switch World
                set_game_world_dir("world");
                
                // 3. Load Player
                let start_x: float = 10.0;
                let start_y: float = 10.0;
                let start_z: float = 10.0;
                
                if (load_player_data(&start_x, &start_y, &start_z, &selected_block) != 0) {
                     start_y += 0.5;
                }
                p = Player::new(start_x, start_y, start_z);
                
                rl::DisableCursor();
            }

            // Chunk Loading for Title (We need to load the sign chunks)
            // Load chunks -2..3 in X, and 0 in Z
            for x in -2..4 {
                 let id_x = x + 3; // 0..6
                 if chunks[id_x].x != x || chunks[id_x].z != 0 {
                     chunks[id_x].x = x;
                     chunks[id_x].z = 0;
                     chunks[id_x].mesh_built = 0;
                     raw { memset(chunks[id_x].blocks, 0, sizeof(chunks[id_x].blocks)); }
                     request_load_async(id_x, x, 0);
                 }
            }
            poll_async_results(&chunks[0], MAX_CHUNKS);

            // Draw
            rl::BeginDrawing();
            rl::ClearBackground(rl::Color{r: 20, g: 20, b: 30, a: 255}); // Dark blue space/night

            rl::BeginMode3D(title_cam);
            raw { rlDisableBackfaceCulling(); }
            
            // Draw Title Chunks
             for i in 0..MAX_CHUNKS {
                if chunks[i].x != -9999 {
                    // Title chunks don't need throttling really, there are few
                    chunks[i].draw(&chunks[0], MAX_CHUNKS, &i, 100); 
                }
            }
            rl::EndMode3D();

            rl::DrawText("ZEN CRAFT", 100, 100, 60, rl::WHITE);
            rl::DrawText("Press ENTER to Play", 150, 400, 30, rl::LIGHTGRAY);
            
            rl::EndDrawing();
        }
        else {
             // --- GAME LOOP ---
             
             // --- CHUNK UPDATE LOGIC ---
            let pcx = (int)floor(p.x / 16.0);
            let pcz = (int)floor(p.z / 16.0);
            
            let range_limit = RENDER_DISTANCE + 1;
            for dx in -RENDER_DISTANCE..range_limit {
                 for dz in -RENDER_DISTANCE..range_limit {
                     let cx = pcx + dx;
                     let cz = pcz + dz;
                     let idx = get_chunk_index(cx, cz);
                     
                     if chunks[idx].x != cx || chunks[idx].z != cz {
                         if chunks[idx].x != -9999 {
                             request_save_async(&chunks[idx]);
                             chunks[idx].x = -9999;
                         }
                         
                         chunks[idx].x = cx;
                         chunks[idx].z = cz;
                         chunks[idx].mesh_built = 0;
                         chunks[idx].light[0][0][0] = -1;
                         raw { memset(chunks[idx].blocks, 0, sizeof(chunks[idx].blocks)); }
                         
                         request_load_async(idx, cx, cz);
                     }
                 }
            }
            
            (&p).update(&chunks[0], MAX_CHUNKS, dt);
            
            poll_async_results(&chunks[0], MAX_CHUNKS);
    
            // Block selection input
            if rl::IsKeyPressed(rl::KEY_ONE) { selected_block = BLOCK_DIRT; }
            if rl::IsKeyPressed(rl::KEY_TWO) { selected_block = BLOCK_GRASS; }
            if rl::IsKeyPressed(rl::KEY_THREE) { selected_block = BLOCK_STONE; }
            if rl::IsKeyPressed(rl::KEY_FOUR) { selected_block = BLOCK_LOG; }
            if rl::IsKeyPressed(rl::KEY_FIVE) { selected_block = BLOCK_LEAVES; }
    
            rl::BeginDrawing();
            rl::ClearBackground(rl::Color{r: 135, g: 206, b: 235, a: 255});
    
            draw_sky(p.camera);
    
            rl::BeginMode3D(p.camera);
            raw { rlDisableBackfaceCulling(); }
    
            let builds_in_frame = 0;
            let max_builds = 1; 
    
            for i in 0..MAX_CHUNKS {
                let c: Chunk* = &chunks[i];
                if c.x != -9999 {
                    c.draw(&chunks[0], MAX_CHUNKS, &builds_in_frame, max_builds);
                }
            }
    
            // Block interaction
            let screen_center = rl::Vector2{
                x: (float)rl::GetScreenWidth() / 2.0,
                y: (float)rl::GetScreenHeight() / 2.0
            };
            let pick_ray = rl::GetScreenToWorldRay(screen_center, p.camera);
    
            let hit = raycast(&chunks[0], MAX_CHUNKS, pick_ray.position.x, pick_ray.position.y, pick_ray.position.z, 
                              pick_ray.direction.x, pick_ray.direction.y, pick_ray.direction.z, 5.0);
    
            if hit.hit != 0 {
                let hx = (float)hit.x;
                let hy = (float)hit.y;
                let hz = (float)hit.z;
                rl::DrawCubeWires(rl::Vector3{x: hx + 0.5, y: hy + 0.5, z: hz + 0.5}, 1.01, 1.01, 1.01, rl::BLACK);
    
                if rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_LEFT) {
                    set_block(&chunks[0], MAX_CHUNKS, hit.x, hit.y, hit.z, BLOCK_AIR);
                    update_sunlight_column(&chunks[0], MAX_CHUNKS, hit.x, hit.z);
                    let cx = (int)floor((float)hit.x / 16.0);
                    let cz = (int)floor((float)hit.z / 16.0);
                    let idx = get_chunk_index(cx, cz);
                    propagate_light_in_chunk(&chunks[idx], &chunks[0], MAX_CHUNKS);
                    chunks[idx].mesh_dirty = 1;
                    
                    // Neighbors (Quick and dirty copy paste from before - refactor later?)
                    let lx = ((hit.x % 16) + 16) % 16;
                    let lz = ((hit.z % 16) + 16) % 16;
                    
                    if lx == 0 { chunks[get_chunk_index(cx - 1, cz)].mesh_dirty = 1; }
                    if lx == 15 { chunks[get_chunk_index(cx + 1, cz)].mesh_dirty = 1; }
                    if lz == 0 { chunks[get_chunk_index(cx, cz - 1)].mesh_dirty = 1; }
                    if lz == 15 { chunks[get_chunk_index(cx, cz + 1)].mesh_dirty = 1; }
                }
                else if rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_RIGHT) {
                    let nx = hit.x + hit.face_x;
                    let ny = hit.y + hit.face_y;
                    let nz = hit.z + hit.face_z;
    
                    let dist_x = p.x - ((float)nx + 0.5);
                    let dist_y = p.y + 1.6 - ((float)ny + 0.5);
                    let dist_z = p.z - ((float)nz + 0.5);
                    if (dist_x*dist_x + dist_y*dist_y + dist_z*dist_z) > 2.0 {
                         set_block(&chunks[0], MAX_CHUNKS, nx, ny, nz, selected_block);
                         update_sunlight_column(&chunks[0], MAX_CHUNKS, nx, nz);
                         let cx = (int)floor((float)nx / 16.0);
                         let cz = (int)floor((float)nz / 16.0);
                         let idx = get_chunk_index(cx, cz);
                         propagate_light_in_chunk(&chunks[idx], &chunks[0], MAX_CHUNKS);
                         chunks[idx].mesh_dirty = 1;
                         
                         let lx = ((nx % 16) + 16) % 16;
                         let lz = ((nz % 16) + 16) % 16;
                         if lx == 0 { chunks[get_chunk_index(cx - 1, cz)].mesh_dirty = 1; }
                         if lx == 15 { chunks[get_chunk_index(cx + 1, cz)].mesh_dirty = 1; }
                         if lz == 0 { chunks[get_chunk_index(cx, cz - 1)].mesh_dirty = 1; }
                         if lz == 15 { chunks[get_chunk_index(cx, cz + 1)].mesh_dirty = 1; }
                    }
                }
            }
    
            rl::EndMode3D();
    
            // HUD
            let sw = rl::GetScreenWidth();
            let sh = rl::GetScreenHeight();
            rl::DrawRectangle(sw/2 - 5, sh/2 - 1, 10, 2, rl::RED);
            rl::DrawRectangle(sw/2 - 1, sh/2 - 5, 2, 10, rl::RED);
    
            rl::DrawText("Zen Craft", 10, 10, 20, rl::DARKGRAY);
            rl::DrawText("Select: 1-5", 10, 30, 20, rl::DARKGRAY);
            rl::DrawText(rl::TextFormat("Block: %d", selected_block), 10, 50, 20, rl::BLACK);
            rl::DrawText(rl::TextFormat("Pos: %.1f, %.1f, %.1f", p.x, p.y, p.z), 10, 75, 20, rl::BLACK);
            
            rl::DrawFPS(10, 100);
            rl::EndDrawing();
        }
    }
    
    // Save on exit (Only if in GAME state, to avoid saving Title world as Player world or vice versa??)
    // Actually, saving chunks is safe because they use `world_dir`.
    // But we should only save PLAYER data if we are in GAME state.
    
    if current_state == STATE_GAME {
        save_player_data(p.x, p.y, p.z, selected_block);
    }

    // Flush chunks (for whatever world is active)
    for i in 0..MAX_CHUNKS {
        if chunks[i].x != -9999 {
            request_save_async(&chunks[i]);
        }
    }
    
    raw {
        #if defined(_WIN32)
        Sleep(100);
        #else
        usleep(100000);
        #endif
    }
}

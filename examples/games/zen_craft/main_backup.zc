//> link: -lraylib -lm

import "raylib.h" as rl;
import "rlgl.h";
import "math.h";

def SCREEN_WIDTH = 1920;
def SCREEN_HEIGHT = 1080;
def TITLE = "Zen Craft";

// Block Types (Enum)
def BLOCK_AIR = 0;
def BLOCK_DIRT = 1;
def BLOCK_GRASS = 2;
def BLOCK_STONE = 3;

// Physics Constants
def GRAVITY = 18.0;
def JUMP_FORCE = 8.0;
def MOVE_SPEED = 5.0;

// ** World / Chunk **

struct Chunk {
    blocks: int[16][16][16]; // x, y, z
    light: int[16][16][16];  // Light levels 0-15
    
    // Consolidated Mesh (Single draw call per chunk)
    chunk_mesh: rl::Mesh;
    chunk_model: rl::Model;
    mesh_dirty: int; // 1 = needs rebuild
    mesh_built: int; // 1 = mesh has been created
    
    x: int;
    z: int;
}

struct LightNode {
    x: int;
    y: int;
    z: int;
}

// Simple fixed-size queue for flood fill
struct LightQueue {
    nodes: LightNode[20000];
    head: int;
    tail: int;
}

fn queue_push(q: LightQueue*, x: int, y: int, z: int) {
    if q.tail < 20000 {
        q.nodes[q.tail].x = x;
        q.nodes[q.tail].y = y;
        q.nodes[q.tail].z = z;
        q.tail += 1;
    }
}

fn queue_pop(q: LightQueue*) -> LightNode {
    let n: LightNode;
    n = q.nodes[q.head];
    q.head += 1;
    return n;
}

fn queue_is_empty(q: LightQueue*) -> int {
    return q.head >= q.tail;
}

// Forward decl
 extern fn GenImagePerlinNoise(width: int, height: int, offsetX: int, offsetY: int, scale: float) -> rl::Image;

fn get_block(chunks: Chunk*, num_chunks: int, x: int, y: int, z: int) -> int;

impl Chunk {
    static fn new(x: int, z: int) -> Chunk {
        let c: Chunk;
        c.x = x;
        c.z = z;

        // Generate Heightmap
        let heights: int[16][16];

        raw {
            Image noise = GenImagePerlinNoise(16, 16, x * 16, z * 16, 0.5f);

            // Use LoadImageColors to safely get pixel data regardless of format
            Color* pixels = LoadImageColors(noise);

            for (int i = 0; i < 16; i++) {
                for (int j = 0; j < 16; j++) {
                    // pixels is row-major: y * width + x
                    // we want x=i, z=j. z is y in image.
                    Color col = pixels[j * 16 + i];
                    int val = col.r; // Grayscale, so r=g=b

                    // Map 0..255 to height 3..15
                    int h = 3 + (val / 20);
                    if (h > 15) h = 15;
                    heights[i][j] = h;
                }
            }
            UnloadImageColors(pixels);
            UnloadImage(noise);
        }

        // Fill Blocks and Light
        for cx in 0..16 {
            for cz in 0..16 {
                let h = heights[cx][cz];
                for cy in 0..16 {
                    // Default light
                    let l = 0;
                    
                    if cy < h - 1 {
                        c.blocks[cx][cy][cz] = BLOCK_STONE;
                    } else if cy < h {
                        c.blocks[cx][cy][cz] = BLOCK_DIRT;
                    } else if cy == h {
                        c.blocks[cx][cy][cz] = BLOCK_GRASS;
                        l = 15; // Surface is lit
                    } else {
                        c.blocks[cx][cy][cz] = BLOCK_AIR;
                        l = 15; // Sky is lit
                    }
                    
                    c.light[cx][cy][cz] = l;
                }
            }
        }
        
        c.mesh_dirty = 1; // Needs initial build
        c.mesh_built = 0; // Not yet created
        return c;
    }

    fn draw(self, chunks: Chunk*, num_chunks: int, atlas_tex: rl::Texture2D) {
        // Rebuild mesh if dirty
        if self.mesh_dirty != 0 {
            build_chunk_mesh(self, chunks, num_chunks, atlas_tex);
        }
        
        // Skip if no mesh built (empty chunk)
        if self.mesh_built == 0 {
            return;
        }
        
        // Draw entire chunk with single draw call!
        let gx_base = self.x * 16;
        let gz_base = self.z * 16;
        
        let offset = rl::Vector3{
            x: (float)gx_base,
            y: 0.0,
            z: (float)gz_base
        };
        
        rl::DrawModel(self.chunk_model, offset, 1.0, rl::WHITE);
    }
}

def RENDER_DISTANCE = 3;
def CHUNK_MAP_SIZE = 7; // RENDER_DISTANCE * 2 + 1
def MAX_CHUNKS = 49;    // CHUNK_MAP_SIZE * CHUNK_MAP_SIZE

// Global helpers for multi-chunk operations (Optimized O(1) Lookup)
fn get_chunk_index(cx: int, cz: int) -> int {
    let mx = ((cx % CHUNK_MAP_SIZE) + CHUNK_MAP_SIZE) % CHUNK_MAP_SIZE;
    let mz = ((cz % CHUNK_MAP_SIZE) + CHUNK_MAP_SIZE) % CHUNK_MAP_SIZE;
    return mz * CHUNK_MAP_SIZE + mx;
}

fn get_block(chunks: Chunk*, num_chunks: int, x: int, y: int, z: int) -> int {
    // Check height bounds
    if y < 0 || y >= 16 { return BLOCK_AIR; }
    
    // Determine chunk coordinates
    let cx = (int)floor((float)x / 16.0);
    let cz = (int)floor((float)z / 16.0);
    
    // Local coordinates
    let lx = ((x % 16) + 16) % 16;
    let lz = ((z % 16) + 16) % 16;

    let idx = get_chunk_index(cx, cz);
    
    if chunks[idx].x == cx && chunks[idx].z == cz {
        return chunks[idx].blocks[lx][y][lz];
    }

    return BLOCK_AIR;
}

fn set_block(chunks: Chunk*, num_chunks: int, x: int, y: int, z: int, type: int) {
    if y < 0 || y >= 16 { return; }

    let cx = (int)floor((float)x / 16.0);
    let cz = (int)floor((float)z / 16.0);
    
    let lx = ((x % 16) + 16) % 16;
    let lz = ((z % 16) + 16) % 16;

    let idx = get_chunk_index(cx, cz);

    if chunks[idx].x == cx && chunks[idx].z == cz {
        chunks[idx].blocks[lx][y][lz] = type;
    }
}

fn get_light_global(chunks: Chunk*, num_chunks: int, x: int, y: int, z: int) -> int {
    if y < 0 || y >= 16 { return 15; } // Sky is bright
    
    let cx = (int)floor((float)x / 16.0);
    let cz = (int)floor((float)z / 16.0);

    let idx = get_chunk_index(cx, cz);

    // If chunk matches, return light. If not loaded, assume sun lit (15) or dark (0)? 
    // Usually border chunks are treated specially, but 0 is safe.
    if chunks[idx].x == cx && chunks[idx].z == cz {
        let lx = ((x % 16) + 16) % 16;
        let lz = ((z % 16) + 16) % 16;
        return chunks[idx].light[lx][y][lz];
    }
    return 0; // Unloaded chunks have no light info
}

fn set_light_global(chunks: Chunk*, num_chunks: int, x: int, y: int, z: int, val: int) {
    if y < 0 || y >= 16 { return; }

    let cx = (int)floor((float)x / 16.0);
    let cz = (int)floor((float)z / 16.0);

    let idx = get_chunk_index(cx, cz);

    if chunks[idx].x == cx && chunks[idx].z == cz {
        let lx = ((x % 16) + 16) % 16;
        let lz = ((z % 16) + 16) % 16;
        chunks[idx].light[lx][y][lz] = val;
    }
}

fn build_chunk_mesh(c: Chunk*, chunks: Chunk*, num_chunks: int, atlas_tex: rl::Texture2D) {
    // Note: We don't unload the old mesh - we just overwrite it
    // This avoids crashes when the mesh is still being referenced
    
    let gx_base = c.x * 16;
    let gz_base = c.z * 16;
    
    raw {
        // Count visible faces first to allocate exact size
        int face_count = 0;
        
        for (int x = 0; x < 16; x++) {
            for (int y = 0; y < 16; y++) {
                for (int z = 0; z < 16; z++) {
                    int btype = c->blocks[x][y][z];
                    if (btype == BLOCK_AIR) continue;
                    
                    int b_gx = gx_base + x;
                    int b_gz = gz_base + z;
                    
                    // Check each face
                    if (get_block(chunks, num_chunks, b_gx + 1, y, b_gz) == BLOCK_AIR) face_count++; // +X
                    if (get_block(chunks, num_chunks, b_gx - 1, y, b_gz) == BLOCK_AIR) face_count++; // -X
                    if (get_block(chunks, num_chunks, b_gx, y + 1, b_gz) == BLOCK_AIR) face_count++; // +Y
                    if (get_block(chunks, num_chunks, b_gx, y - 1, b_gz) == BLOCK_AIR) face_count++; // -Y
                    if (get_block(chunks, num_chunks, b_gx, y, b_gz + 1) == BLOCK_AIR) face_count++; // +Z
                    if (get_block(chunks, num_chunks, b_gx, y, b_gz - 1) == BLOCK_AIR) face_count++; // -Z
                }
            }
        }
        
        if (face_count == 0) {
            // Empty chunk, create dummy mesh
            c->chunk_mesh = GenMeshCube(0.0f, 0.0f, 0.0f);
            c->chunk_model = LoadModelFromMesh(c->chunk_mesh);
            c->mesh_built = 1;
            c->mesh_dirty = 0;
            return;
        }
        
        // Allocate vertex data (6 vertices per face = 2 triangles)
        int vertex_count = face_count * 6;
        float* vertices = (float*)malloc(vertex_count * 3 * sizeof(float));
        float* normals = (float*)malloc(vertex_count * 3 * sizeof(float));
        float* texcoords = (float*)malloc(vertex_count * 2 * sizeof(float));
        unsigned char* colors = (unsigned char*)malloc(vertex_count * 4 * sizeof(unsigned char));
        
        int v_idx = 0;
        
        // Helper macro to add vertex
        #define ADD_VERTEX(px, py, pz, nx, ny, nz, u, v, light_val) \
            vertices[v_idx * 3 + 0] = (float)(px); \
            vertices[v_idx * 3 + 1] = (float)(py); \
            vertices[v_idx * 3 + 2] = (float)(pz); \
            normals[v_idx * 3 + 0] = (nx); \
            normals[v_idx * 3 + 1] = (ny); \
            normals[v_idx * 3 + 2] = (nz); \
            texcoords[v_idx * 2 + 0] = (u); \
            texcoords[v_idx * 2 + 1] = (v); \
            colors[v_idx * 4 + 0] = (light_val); \
            colors[v_idx * 4 + 1] = (light_val); \
            colors[v_idx * 4 + 2] = (light_val); \
            colors[v_idx * 4 + 3] = 255; \
            v_idx++;
        
        // Build mesh
        for (int x = 0; x < 16; x++) {
            for (int y = 0; y < 16; y++) {
                for (int z = 0; z < 16; z++) {
                    int btype = c->blocks[x][y][z];
                    if (btype == BLOCK_AIR) continue;
                    
                    int b_gx = gx_base + x;
                    int b_gz = gz_base + z;
                    
                    float px = (float)x;
                    float py = (float)y;
                    float pz = (float)z;
                    
                    int light = c->light[x][y][z];
                    unsigned char light_val = (unsigned char)(light * 16);
                    if (light_val > 255) light_val = 255;
                    
                    // Texture atlas UVs (2x2 grid: 0.5 per texture)
                    // Layout: [Dirt][Grass_Top]
                    //         [Grass_Side][Stone]
                    float u_min, v_min, u_max, v_max;
                    
                    // +Y face (top) - check each face individually
                    if (get_block(chunks, num_chunks, b_gx, y + 1, b_gz) == BLOCK_AIR) {
                        // Determine top texture
                        if (btype == BLOCK_GRASS) {
                            u_min = 0.5f; v_min = 0.0f; u_max = 1.0f; v_max = 0.5f; // Grass top
                        } else if (btype == BLOCK_DIRT) {
                            u_min = 0.0f; v_min = 0.0f; u_max = 0.5f; v_max = 0.5f; // Dirt
                        } else { // STONE
                            u_min = 0.5f; v_min = 0.5f; u_max = 1.0f; v_max = 1.0f; // Stone
                        }
                        
                        // Top face (Y+) - 2 triangles (looking down at it, CCW)
                        ADD_VERTEX(px, py+1, pz,     0,1,0, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz,   0,1,0, u_max, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 0,1,0, u_max, v_max, light_val);
                        
                        ADD_VERTEX(px, py+1, pz,     0,1,0, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 0,1,0, u_max, v_max, light_val);
                        ADD_VERTEX(px, py+1, pz+1,   0,1,0, u_min, v_max, light_val);
                    }
                    
                    // -Y face (bottom)
                    if (get_block(chunks, num_chunks, b_gx, y - 1, b_gz) == BLOCK_AIR) {
                        // Bottom always uses base texture
                        if (btype == BLOCK_GRASS || btype == BLOCK_DIRT) {
                            u_min = 0.0f; v_min = 0.0f; u_max = 0.5f; v_max = 0.5f; // Dirt
                        } else {
                            u_min = 0.5f; v_min = 0.5f; u_max = 1.0f; v_max = 1.0f; // Stone
                        }
                        
                        // Bottom face (looking up at it from below, CCW)
                        ADD_VERTEX(px, py, pz,     0,-1,0, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py, pz,   0,-1,0, u_max, v_min, light_val);
                        ADD_VERTEX(px+1, py, pz+1, 0,-1,0, u_max, v_max, light_val);
                        
                        ADD_VERTEX(px, py, pz,     0,-1,0, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py, pz+1, 0,-1,0, u_max, v_max, light_val);
                        ADD_VERTEX(px, py, pz+1,   0,-1,0, u_min, v_max, light_val);
                    }
                    
                    // +X face (right)
                    if (get_block(chunks, num_chunks, b_gx + 1, y, b_gz) == BLOCK_AIR) {
                        // Side texture
                        if (btype == BLOCK_GRASS) {
                            u_min = 0.0f; v_min = 0.5f; u_max = 0.5f; v_max = 1.0f; // Grass side
                        } else if (btype == BLOCK_DIRT) {
                            u_min = 0.0f; v_min = 0.0f; u_max = 0.5f; v_max = 0.5f; // Dirt
                        } else {
                            u_min = 0.5f; v_min = 0.5f; u_max = 1.0f; v_max = 1.0f; // Stone
                        }
                        
                        // Right face (looking at it from +X direction, CCW)
                        ADD_VERTEX(px+1, py, pz,     1,0,0, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py, pz+1,   1,0,0, u_max, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 1,0,0, u_max, v_min, light_val);
                        
                        ADD_VERTEX(px+1, py, pz,     1,0,0, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 1,0,0, u_max, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz,   1,0,0, u_min, v_min, light_val);
                    }
                    
                    // -X face (left)
                    if (get_block(chunks, num_chunks, b_gx - 1, y, b_gz) == BLOCK_AIR) {
                        if (btype == BLOCK_GRASS) {
                            u_min = 0.0f; v_min = 0.5f; u_max = 0.5f; v_max = 1.0f;
                        } else if (btype == BLOCK_DIRT) {
                            u_min = 0.0f; v_min = 0.0f; u_max = 0.5f; v_max = 0.5f;
                        } else {
                            u_min = 0.5f; v_min = 0.5f; u_max = 1.0f; v_max = 1.0f;
                        }
                        
                        // Left face (looking at it from -X direction, CCW)
                        ADD_VERTEX(px, py, pz,     -1,0,0, u_min, v_max, light_val);
                        ADD_VERTEX(px, py+1, pz,   -1,0,0, u_min, v_min, light_val);
                        ADD_VERTEX(px, py+1, pz+1, -1,0,0, u_max, v_min, light_val);
                        
                        ADD_VERTEX(px, py, pz,     -1,0,0, u_min, v_max, light_val);
                        ADD_VERTEX(px, py+1, pz+1, -1,0,0, u_max, v_min, light_val);
                        ADD_VERTEX(px, py, pz+1,   -1,0,0, u_max, v_max, light_val);
                    }
                    
                    // +Z face (front)
                    if (get_block(chunks, num_chunks, b_gx, y, b_gz + 1) == BLOCK_AIR) {
                        if (btype == BLOCK_GRASS) {
                            u_min = 0.0f; v_min = 0.5f; u_max = 0.5f; v_max = 1.0f;
                        } else if (btype == BLOCK_DIRT) {
                            u_min = 0.0f; v_min = 0.0f; u_max = 0.5f; v_max = 0.5f;
                        } else {
                            u_min = 0.5f; v_min = 0.5f; u_max = 1.0f; v_max = 1.0f;
                        }
                        
                        // Front face (looking at it from +Z direction, CCW)
                        ADD_VERTEX(px, py, pz+1,     0,0,1, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py, pz+1,   0,0,1, u_max, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 0,0,1, u_max, v_min, light_val);
                        
                        ADD_VERTEX(px, py, pz+1,     0,0,1, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 0,0,1, u_max, v_min, light_val);
                        ADD_VERTEX(px, py+1, pz+1,   0,0,1, u_min, v_min, light_val);
                    }
                    
                    // -Z face (back)
                    if (get_block(chunks, num_chunks, b_gx, y, b_gz - 1) == BLOCK_AIR) {
                        if (btype == BLOCK_GRASS) {
                            u_min = 0.0f; v_min = 0.5f; u_max = 0.5f; v_max = 1.0f;
                        } else if (btype == BLOCK_DIRT) {
                            u_min = 0.0f; v_min = 0.0f; u_max = 0.5f; v_max = 0.5f;
                        } else {
                            u_min = 0.5f; v_min = 0.5f; u_max = 1.0f; v_max = 1.0f;
                        }
                        
                        // Back face (looking at it from -Z direction, CCW)
                        ADD_VERTEX(px, py, pz,     0,0,-1, u_min, v_max, light_val);
                        ADD_VERTEX(px, py+1, pz,   0,0,-1, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz, 0,0,-1, u_max, v_min, light_val);
                        
                        ADD_VERTEX(px, py, pz,     0,0,-1, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz, 0,0,-1, u_max, v_min, light_val);
                        ADD_VERTEX(px+1, py, pz,   0,0,-1, u_max, v_max, light_val);
                    }
                }
            }
        }
        
        #undef ADD_VERTEX
        
        // Create mesh
        Mesh mesh = { 0 };
        mesh.vertexCount = vertex_count;
        mesh.triangleCount = vertex_count / 3;
        mesh.vertices = vertices;
        mesh.normals = normals;
        mesh.texcoords = texcoords;
        mesh.colors = colors;
        
        // Upload to GPU
        UploadMesh(&mesh, false);
        
        c->chunk_mesh = mesh;
        c->chunk_model = LoadModelFromMesh(mesh);
        
        // Assign shader and texture
        extern Shader sh_lighting;
        c->chunk_model.materials[0].shader = sh_lighting;
        c->chunk_model.materials[0].maps[MATERIAL_MAP_DIFFUSE].texture = atlas_tex;
        
        c->mesh_built = 1;
        c->mesh_dirty = 0;
    }
}

fn update_sunlight_column(chunks: Chunk*, num_chunks: int, x: int, z: int) {
    let casting_shadow = 0;
    
    for i in 0..16 {
        let y = 15 - i;
        let blk = get_block(chunks, num_chunks, x, y, z);
        
        if casting_shadow == 0 {
             if blk != BLOCK_AIR {
                 // Found surface, this block is lit, but below is shadow
                 set_light_global(chunks, num_chunks, x, y, z, 15);
                 casting_shadow = 1;
             } else {
                 set_light_global(chunks, num_chunks, x, y, z, 15);
             }
        } else {
             // Underground
             set_light_global(chunks, num_chunks, x, y, z, 0);
        }
    }
}

struct RaycastHit {
    hit: int;
    x: int;
    y: int;
    z: int;
    face_x: int;
    face_y: int;
    face_z: int;
}

fn raycast(chunks: Chunk*, num_chunks: int, ox: float, oy: float, oz: float, dx: float, dy: float, dz: float, max_dist: float) -> RaycastHit {
    let r: RaycastHit;
    r.hit = 0;

    let x = ox;
    let y = oy;
    let z = oz;

    let step = 0.05;
    let dist = 0.0;

    let last_x = (int)floor(x);
    let last_y = (int)floor(y);
    let last_z = (int)floor(z);

    while dist < max_dist {
        x += dx * step;
        y += dy * step;
        z += dz * step;
        dist += step;

        let ix = (int)floor(x);
        let iy = (int)floor(y);
        let iz = (int)floor(z);

        if get_block(chunks, num_chunks, ix, iy, iz) != BLOCK_AIR {
            r.hit = 1;
            r.x = ix;
            r.y = iy;
            r.z = iz;

            // Determine face
            r.face_x = 0;
            r.face_y = 0;
            r.face_z = 0;

            if ix > last_x { r.face_x = -1; }
            else if ix < last_x { r.face_x = 1; }
            else if iy > last_y { r.face_y = -1; }
            else if iy < last_y { r.face_y = 1; }
            else if iz > last_z { r.face_z = -1; }
            else if iz < last_z { r.face_z = 1; }

            return r;
        }

        last_x = ix;
        last_y = iy;
        last_z = iz;
    }

    return r;
}

// Raylib Externs
extern fn DrawCubeTexture(texture: rl::Texture2D, position: rl::Vector3, width: float, height: float, length: float, color: rl::Color);

// Textures & Models
let model_dirt: rl::Model;
let model_grass: rl::Model;
let model_stone: rl::Model;
let tex_sun: rl::Texture2D;
let tex_moon: rl::Texture2D;
let sh_lighting: rl::Shader;

// Global texture IDs for batched rendering
let tex_dirt: rl::Texture2D;
let tex_grass: rl::Texture2D;
let tex_stone: rl::Texture2D;

// Raw texture IDs for rlgl (stored as int since Zen-C doesn't have unsigned int easily)
let tex_dirt_id: int;
let tex_grass_id: int;
let tex_stone_id: int;

// Batch draw a single cube at position using rlgl (36 vertices)
fn draw_cube_batch(px: float, py: float, pz: float, r: int, g: int, b: int) {
    let s = 0.5; // half size
    
    raw {
        // Front Face
        rlNormal3f(0.0f, 0.0f, 1.0f);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px - s, py - s, pz + s);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px + s, py - s, pz + s);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px + s, py + s, pz + s);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px + s, py + s, pz + s);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px - s, py + s, pz + s);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px - s, py - s, pz + s);
        
        // Back Face
        rlNormal3f(0.0f, 0.0f, -1.0f);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px - s, py - s, pz - s);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px - s, py + s, pz - s);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px + s, py + s, pz - s);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px + s, py + s, pz - s);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px + s, py - s, pz - s);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px - s, py - s, pz - s);
        
        // Top Face
        rlNormal3f(0.0f, 1.0f, 0.0f);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px - s, py + s, pz - s);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px - s, py + s, pz + s);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px + s, py + s, pz + s);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px + s, py + s, pz + s);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px + s, py + s, pz - s);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px - s, py + s, pz - s);
        
        // Bottom Face
        rlNormal3f(0.0f, -1.0f, 0.0f);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px - s, py - s, pz - s);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px + s, py - s, pz - s);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px + s, py - s, pz + s);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px + s, py - s, pz + s);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px - s, py - s, pz + s);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px - s, py - s, pz - s);
        
        // Right Face
        rlNormal3f(1.0f, 0.0f, 0.0f);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px + s, py - s, pz - s);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px + s, py + s, pz - s);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px + s, py + s, pz + s);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px + s, py + s, pz + s);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px + s, py - s, pz + s);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px + s, py - s, pz - s);
        
        // Left Face
        rlNormal3f(-1.0f, 0.0f, 0.0f);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px - s, py - s, pz - s);
        rlTexCoord2f(1.0f, 1.0f); rlVertex3f(px - s, py - s, pz + s);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px - s, py + s, pz + s);
        rlTexCoord2f(1.0f, 0.0f); rlVertex3f(px - s, py + s, pz + s);
        rlTexCoord2f(0.0f, 0.0f); rlVertex3f(px - s, py + s, pz - s);
        rlTexCoord2f(0.0f, 1.0f); rlVertex3f(px - s, py - s, pz - s);
    }
}

fn load_texture_from_memory(_data: char*, _len: int) -> rl::Texture2D {
    let tex: rl::Texture2D;
    raw {
        Image img = LoadImageFromMemory(".png", (unsigned char*)_data, _len);
        tex = LoadTextureFromImage(img);
        SetTextureFilter(tex, TEXTURE_FILTER_POINT);
        UnloadImage(img);
    }
    return tex;
}

fn load_shader_from_memory(_vs: char*, _vs_len: int, _fs: char*, _fs_len: int) -> rl::Shader {
    let sh: rl::Shader;
    raw {
        char* vs = (char*)MemAlloc(_vs_len + 1);
        memcpy(vs, _vs, _vs_len);
        vs[_vs_len] = '\0';

        char* fs = (char*)MemAlloc(_fs_len + 1);
        memcpy(fs, _fs, _fs_len);
        fs[_fs_len] = '\0';

        sh = LoadShaderFromMemory(vs, fs);

        MemFree(vs);
        MemFree(fs);
    }
    return sh;
}

fn init_textures() -> rl::Texture2D {
    let atlas_data = embed "./assets/atlas.png";
    let sun_data = embed "./assets/sun.png";
    let moon_data = embed "./assets/moon.png";
    
    let vs_data = embed "./assets/lighting.vs";
    let fs_data = embed "./assets/lighting.fs";

    let tex_atlas = load_texture_from_memory(atlas_data.data, atlas_data.len);
    tex_sun = load_texture_from_memory(sun_data.data, sun_data.len);
    tex_moon = load_texture_from_memory(moon_data.data, moon_data.len);
    
    sh_lighting = load_shader_from_memory(vs_data.data, vs_data.len, fs_data.data, fs_data.len);

    // No longer need individual models - chunks build their own meshes
    
    return tex_atlas;
}

fn draw_sky(camera: rl::Camera3D) {
    // Disable Depth Mask to draw sky behind everything
    rl::BeginMode3D(camera);
        // Simple Fixed Sun Position or billboard
        let sun_pos = rl::Vector3{x: camera.position.x + 20.0, y: camera.position.y + 40.0, z: camera.position.z + 20.0};

        raw {
            DrawBillboard(camera, tex_sun, sun_pos, 10.0f, WHITE);
        }
    rl::EndMode3D();
}

struct Player {
    x: float;
    y: float;
    z: float;
    vx: float;
    vy: float;
    vz: float;
    yaw: float;
    pitch: float;
    camera: rl::Camera3D;
}

fn check_collision(chunks: Chunk*, num_chunks: int, x: float, y: float, z: float, w: float, h: float) -> int {
    let min_x = (int)floor(x - w/2.0);
    let max_x = (int)floor(x + w/2.0);
    let min_y = (int)floor(y);
    let max_y = (int)floor(y + h);
    let min_z = (int)floor(z - w/2.0);
    let max_z = (int)floor(z + w/2.0);

    for ix in min_x..max_x+1 {
        for iy in min_y..max_y+1 {
            for iz in min_z..max_z+1 {
                if get_block(chunks, num_chunks, ix, iy, iz) != BLOCK_AIR {
                    return 1;
                }
            }
        }
    }
    return 0;
}

impl Player {
    static fn new(x: float, y: float, z: float) -> Player {
        let p: Player;
        p.x = x;
        p.y = y;
        p.z = z;
        p.vx = 0.0;
        p.vy = 0.0;
        p.vz = 0.0;
        p.yaw = 0.0;
        p.pitch = 0.0;

        p.camera = rl::Camera3D{
            position: rl::Vector3{x: x, y: y, z: z},
            target: rl::Vector3{x: x+1.0, y: y, z: z},
            up: rl::Vector3{x: 0.0, y: 1.0, z: 0.0},
            fovy: 70.0,
            projection: rl::CAMERA_PERSPECTIVE
        };
        return p;
    }

    fn update(self, chunks: Chunk*, num_chunks: int, dt: float) {
        // Mouse look
        let mouse_delta = rl::GetMouseDelta();
        self.yaw += mouse_delta.x * 0.003;
        self.pitch += mouse_delta.y * 0.003;

        if self.pitch > 1.5 { self.pitch = 1.5; }
        if self.pitch < -1.5 { self.pitch = -1.5; }

        // Movement input
        let dx = 0.0;
        let dz = 0.0;
        if rl::IsKeyDown(rl::KEY_W) { dx += 1.0; }
        if rl::IsKeyDown(rl::KEY_S) { dx -= 1.0; }
        if rl::IsKeyDown(rl::KEY_A) { dz -= 1.0; }
        if rl::IsKeyDown(rl::KEY_D) { dz += 1.0; }

        let fx = cos(self.yaw);
        let fz = sin(self.yaw);
        let rx = -sin(self.yaw);
        let rz = cos(self.yaw);

        let move_x = fx * dx + rx * dz;
        let move_z = fz * dx + rz * dz;

        let mlen = sqrt(move_x*move_x + move_z*move_z);
        if mlen > 0.001 {
            move_x /= mlen;
            move_z /= mlen;
            self.vx = move_x * MOVE_SPEED;
            self.vz = move_z * MOVE_SPEED;
        } else {
            self.vx = 0.0;
            self.vz = 0.0;
        }

        // Gravity and jump
        self.vy -= (float)GRAVITY * dt;

        if rl::IsKeyPressed(rl::KEY_SPACE) {
             // Only jump if on ground (check slightly below)
             if check_collision(chunks, num_chunks, self.x, self.y - 0.1, self.z, 0.6, 1.8) {
                 self.vy = JUMP_FORCE;
             }
        }

        // Physics integration (Separate Axes)
        let box_w = 0.6;
        let box_h = 1.8;

        // X axis
        self.x += self.vx * dt;
        if check_collision(chunks, num_chunks, self.x, self.y, self.z, box_w, box_h) {
            self.x -= self.vx * dt; // Revert
            self.vx = 0.0;
        }

        // Z axis
        self.z += self.vz * dt;
        if check_collision(chunks, num_chunks, self.x, self.y, self.z, box_w, box_h) {
            self.z -= self.vz * dt; // Revert
            self.vz = 0.0;
        }

        // Y axis
        self.y += self.vy * dt;
        if check_collision(chunks, num_chunks, self.x, self.y, self.z, box_w, box_h) {
            self.y -= self.vy * dt; // Revert
            self.vy = 0.0;
        }

        // Check World Floor (Void Safety)
        if self.y < -10.0 {
            self.y = 20.0;
            self.vy = 0.0;
        }

        // Sync Camera
        let view_x = cos(self.yaw) * cos(self.pitch);
        let view_z = sin(self.yaw) * cos(self.pitch);
        let view_y = -sin(self.pitch);

        self.camera.position.x = self.x;
        self.camera.position.y = self.y + 1.6;
        self.camera.position.z = self.z;

        self.camera.target.x = self.camera.position.x + view_x;
        self.camera.target.y = self.camera.position.y + view_y;
        self.camera.target.z = self.camera.position.z + view_z;
    }
}

fn main() {
    rl::InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, TITLE);
    rl::SetWindowState(rl::FLAG_WINDOW_RESIZABLE);
    defer { rl::CloseWindow(); }

    rl::SetTargetFPS(60);

    // Load Assets
    let tex_atlas = init_textures();

    // Initialize Player
    let p = Player::new(10.0, 10.0, 10.0);
    let selected_block = BLOCK_STONE;

    // Generate Chunks
    // Buffer size: MAX_CHUNKS
    let chunks: Chunk*;
    raw {
        chunks = (Chunk*)MemAlloc(sizeof(Chunk) * MAX_CHUNKS);
    }
    
    // Initialize empty chunks
    for i in 0..MAX_CHUNKS {
        chunks[i].x = -9999;
        chunks[i].z = -9999;
    }

    rl::DisableCursor(); // Capture mouse
    
    // Track previous position to avoid unnecessary updates
    let last_pcx = -99999;
    let last_pcz = -99999;

    while !rl::WindowShouldClose() {
        let dt: float = rl::GetFrameTime();
        
        // --- CHUNK UPDATE LOGIC ---
        let pcx = (int)floor(p.x / 16.0);
        let pcz = (int)floor(p.z / 16.0);
        
        // Simple update each frame or only when moving chunks?
        // Doing it every frame ensures smooth loading, but we can distribute work.
        // For simplicity now, we check the whole area but only generate 1 chunk per frame to prevent stutter?
        // Or just generate needed ones. 'Chunk::new' takes ~ms.
        
        // Full update loop
        // Zen-C ranges are exclusive of the upper bound, so we go to RENDER_DISTANCE + 1
        let range_limit = RENDER_DISTANCE + 1;
        for dx in -RENDER_DISTANCE..range_limit {
             for dz in -RENDER_DISTANCE..range_limit {
                 let cx = pcx + dx;
                 let cz = pcz + dz;
                 let idx = get_chunk_index(cx, cz);
                 
                 if chunks[idx].x != cx || chunks[idx].z != cz {
                     chunks[idx] = Chunk::new(cx, cz);
                     // Lighting updated in Chunk::new
                     
                     // We need to build the mesh. 
                     // Also, neighbors might need rebuilding if we appeared next to them.
                     // For simplicity, just build self now. Neighbors will update eventually or we force them.
                     chunks[idx].mesh_dirty = 1;
                 }
             }
        }
        
        (&p).update(&chunks[0], MAX_CHUNKS, dt);

        // Block selection input
        if rl::IsKeyPressed(rl::KEY_ONE) { selected_block = BLOCK_DIRT; }
        if rl::IsKeyPressed(rl::KEY_TWO) { selected_block = BLOCK_GRASS; }
        if rl::IsKeyPressed(rl::KEY_THREE) { selected_block = BLOCK_STONE; }

        rl::BeginDrawing();
        // Sky blue background
        rl::ClearBackground(rl::Color{r: 135, g: 206, b: 235, a: 255});

        draw_sky(p.camera);

        rl::BeginMode3D(p.camera);
        
        // Disable back-face culling to see all faces
        raw {
            rlDisableBackfaceCulling();
        }

        // Render visible chunks
        // We can just iterate the buffer, or iterate the view radius for Frustum Culling later
        for i in 0..MAX_CHUNKS {
            let c: Chunk* = &chunks[i];
            // Simple frustum/distance check could go here
             // Only draw if valid
            if c.x != -9999 {
                c.draw(&chunks[0], MAX_CHUNKS, tex_atlas);
            }
        }

        // Block interaction
        let screen_center = rl::Vector2{
            x: (float)rl::GetScreenWidth() / 2.0,
            y: (float)rl::GetScreenHeight() / 2.0
        };
        let pick_ray = rl::GetScreenToWorldRay(screen_center, p.camera);

        let hit = raycast(&chunks[0], MAX_CHUNKS, pick_ray.position.x, pick_ray.position.y, pick_ray.position.z, 
                          pick_ray.direction.x, pick_ray.direction.y, pick_ray.direction.z, 5.0);

        if hit.hit != 0 {
            // Draw selection
            let hx = (float)hit.x;
            let hy = (float)hit.y;
            let hz = (float)hit.z;

            // Draw slight offset wireframe
            rl::DrawCubeWires(rl::Vector3{x: hx + 0.5, y: hy + 0.5, z: hz + 0.5}, 1.01, 1.01, 1.01, rl::BLACK);

            // Input handling
            if rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_LEFT) {
                set_block(&chunks[0], MAX_CHUNKS, hit.x, hit.y, hit.z, BLOCK_AIR);
                update_sunlight_column(&chunks[0], MAX_CHUNKS, hit.x, hit.z);
                
                // Rebuild the chunk modified
                let cx = (int)floor((float)hit.x / 16.0);
                let cz = (int)floor((float)hit.z / 16.0);
                let idx = get_chunk_index(cx, cz);
                chunks[idx].mesh_dirty = 1;
                
                // Update neighbor chunks if block was at edge
                let lx = ((hit.x % 16) + 16) % 16;
                let lz = ((hit.z % 16) + 16) % 16;
                
                if lx == 0 {
                    let idx_west = get_chunk_index(cx - 1, cz);
                    if chunks[idx_west].x == (cx - 1) && chunks[idx_west].z == cz {
                        chunks[idx_west].mesh_dirty = 1;
                    }
                }
                if lx == 15 {
                    let idx_east = get_chunk_index(cx + 1, cz);
                    if chunks[idx_east].x == (cx + 1) && chunks[idx_east].z == cz {
                        chunks[idx_east].mesh_dirty = 1;
                    }
                }
                if lz == 0 {
                    let idx_south = get_chunk_index(cx, cz - 1);
                    if chunks[idx_south].x == cx && chunks[idx_south].z == (cz - 1) {
                        chunks[idx_south].mesh_dirty = 1;
                    }
                }
                if lz == 15 {
                    let idx_north = get_chunk_index(cx, cz + 1);
                    if chunks[idx_north].x == cx && chunks[idx_north].z == (cz + 1) {
                        chunks[idx_north].mesh_dirty = 1;
                    }
                }
            }
            else if rl::IsMouseButtonPressed(rl::MOUSE_BUTTON_RIGHT) {
                let nx = hit.x + hit.face_x;
                let ny = hit.y + hit.face_y;
                let nz = hit.z + hit.face_z;

                // Don't place inside player (Simple check)
                let dist_x = p.x - ((float)nx + 0.5);
                let dist_y = p.y + 1.6 - ((float)ny + 0.5); // Eye pos vs block center
                let dist_z = p.z - ((float)nz + 0.5);
                if (dist_x*dist_x + dist_y*dist_y + dist_z*dist_z) > 2.0 {
                     set_block(&chunks[0], MAX_CHUNKS, nx, ny, nz, selected_block);
                     update_sunlight_column(&chunks[0], MAX_CHUNKS, nx, nz);
                     
                     let cx = (int)floor((float)nx / 16.0);
                     let cz = (int)floor((float)nz / 16.0);
                     let idx = get_chunk_index(cx, cz);
                     chunks[idx].mesh_dirty = 1;
                     
                     // Update neighbor chunks if block was at edge
                     let lx = ((nx % 16) + 16) % 16;
                     let lz = ((nz % 16) + 16) % 16;
                     
                     if lx == 0 {
                         let idx_west = get_chunk_index(cx - 1, cz);
                         if chunks[idx_west].x == (cx - 1) && chunks[idx_west].z == cz {
                             chunks[idx_west].mesh_dirty = 1;
                         }
                     }
                     if lx == 15 {
                         let idx_east = get_chunk_index(cx + 1, cz);
                         if chunks[idx_east].x == (cx + 1) && chunks[idx_east].z == cz {
                             chunks[idx_east].mesh_dirty = 1;
                         }
                     }
                     if lz == 0 {
                         let idx_south = get_chunk_index(cx, cz - 1);
                         if chunks[idx_south].x == cx && chunks[idx_south].z == (cz - 1) {
                             chunks[idx_south].mesh_dirty = 1;
                         }
                     }
                     if lz == 15 {
                         let idx_north = get_chunk_index(cx, cz + 1);
                         if chunks[idx_north].x == cx && chunks[idx_north].z == (cz + 1) {
                             chunks[idx_north].mesh_dirty = 1;
                         }
                     }
                }
            }
        }

        rl::EndMode3D();

        // Draw HUD
        let sw = rl::GetScreenWidth();
        let sh = rl::GetScreenHeight();
        rl::DrawRectangle(sw/2 - 5, sh/2 - 1, 10, 2, rl::RED); // Horizontal
        rl::DrawRectangle(sw/2 - 1, sh/2 - 5, 2, 10, rl::RED); // Vertical

        rl::DrawText("Zen Craft - Infinite Procedural", 10, 10, 20, rl::DARKGRAY);
        rl::DrawText("WASD+Mouse: Move | Click: Break/Place", 10, 30, 20, rl::DARKGRAY);
        rl::DrawFPS(10, 100);

        rl::EndDrawing();
    }
}

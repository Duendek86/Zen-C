//> Persistence implementation
import "raylib.h" as rl;
import "chunk.zc";

// Global constants for Async System
def MAX_PENDING_IO = 64;

// Request Types
def REQ_NONE = 0;
def REQ_SAVE = 1;
def REQ_LOAD = 2;

// Request Status
def IO_STATUS_FREE = 0;
def IO_STATUS_PENDING = 1;
def IO_STATUS_COMPLETED = 2;
def IO_STATUS_FAILED = 3;

// We need a Data struct that can hold a chunk's data for off-thread processing
struct ChunkData {
    blocks: int[16][128][16];
    light: int[16][128][16];
    plant_count: int;
    plants: Plant[64];
    light_calculated: int; // 1 if lighting was computed by generator
}

struct IORequest {
    status: int;      // Thread-safe flag
    type: int;        // REQ_SAVE or REQ_LOAD
    cx: int;
    cz: int;
    target_idx: int;  // Index in global chunks array (for writeback)
    data: ChunkData;  // Data buffer (Copy for save, Target for load)
}

struct AsyncSystem {
    requests: IORequest[64];
    running: int;
}

// Thread-safe pseudo-random number generator
// Linear Congruential Generator
fn my_rand(seed: int*) -> int {
    raw {
        *seed = (*seed * 1103515245 + 12345) & 0x7fffffff;
        return *seed;
    }
    return 0; // Unreachable
}

// This prototyp needs to be visible to db_worker, but implementation is elsewhere or dynamic?
// For now, keep it here as the default generator
fn generate_chunk_data(data: ChunkData*, x: int, z: int) {
    // 1. Generate Heightmap
    let heights: int[16][16];
    
    raw {
        // We use Raylib's GenImagePerlinNoise. 
        // SMOOTHER TERRAIN: Lower scale from 0.5 to 0.05
        Image noise = GenImagePerlinNoise(16, 16, x * 16, z * 16, 0.05f);
        Color* pixels = LoadImageColors(noise);
        
        for(int i=0; i<16; i++) {
            for(int j=0; j<16; j++) {
                // pixels is row-major
                Color col = pixels[j * 16 + i];
                int val = col.r;
                
                // Map 0..255 to height 4..64 (Lower mountains)
                int h = 4 + (val / 4);
                if (h > CHUNK_HEIGHT - 10) h = CHUNK_HEIGHT - 10;
                heights[i][j] = h;
            }
        }
        UnloadImageColors(pixels);
        UnloadImage(noise);
    }
    
    // 2. Fill Blocks
    for cx in 0..16 {
        for cz in 0..16 {
            let h = heights[cx][cz];
            for cy in 0..CHUNK_HEIGHT {
                let l = 0;
                if cy < h - 1 {
                    data.blocks[cx][cy][cz] = BLOCK_STONE;
                } else if cy < h {
                    data.blocks[cx][cy][cz] = BLOCK_DIRT;
                } else if cy == h {
                    data.blocks[cx][cy][cz] = BLOCK_GRASS;
                    l = 240; // Sky Light 15 (0xF0), Block Light 0
                } else {
                    data.blocks[cx][cy][cz] = BLOCK_AIR;
                    l = 240; // Sky Light 15 (0xF0), Block Light 0
                }
                data.light[cx][cy][cz] = l;
            }
        }
    }
    
    // 2.5. Water Generation (Lakes)
    // Fill air blocks below sea level with water
    def SEA_LEVEL = 15;
    for cx in 0..16 {
        for cz in 0..16 {
            for cy in 0..SEA_LEVEL {
                if data.blocks[cx][cy][cz] == BLOCK_AIR {
                    data.blocks[cx][cy][cz] = BLOCK_WATER;
                    // Water is transparent, keep sky light at 240
                }
            }
        }
    }
    
    // 3. Plants/Trees
    data.plant_count = 0;
    
    // Deterministic seed for this chunk
    let seed = x * 73856093 ^ z * 19349663;
    
    // Forest Noise (Low frequency for biomes)
    let forest_noise_val = 0.0;
    
    raw {
         // Using a specific offset for forest noise to de-correlate from terrain height
        Image fnoise = GenImagePerlinNoise(1, 1, x, z, 0.02f); 
        Color* fp = LoadImageColors(fnoise);
        forest_noise_val = (float)fp[0].r / 255.0; // 0.0 to 1.0
        UnloadImageColors(fp);
        UnloadImage(fnoise);
    }
    
    // Determine tree density based on forest noise
    // > 0.6 : Forest
    // < 0.4 : Plains
    // 0.4-0.6 : Transition
    let tree_chance_threshold = 1; // 1% default (Sparse)
    
    if forest_noise_val > 0.55 {
        tree_chance_threshold = 10; // 10% (Forest)
        if forest_noise_val > 0.7 {
             tree_chance_threshold = 15; // 15% (Dense Forest)
        }
    } else if forest_noise_val < 0.3 {
        tree_chance_threshold = 0; // 0.5% approx (Very Sparse) -> handled by rand check
    }
    
    for cx in 0..16 {
        for cz in 0..16 {
            let h = heights[cx][cz];
            // Grass
            if data.blocks[cx][h][cz] == BLOCK_GRASS && h < CHUNK_HEIGHT - 20 {
                let r = my_rand(&seed) % 1000; // 0..999
                
                // Adjust chance based on threshold
                let place_tree = 0;
                if tree_chance_threshold > 0 {
                    if r < tree_chance_threshold * 10 { place_tree = 1; }
                } else {
                     // Very sparse
                     if r < 2 { place_tree = 1; } // 0.2%
                }

                if place_tree { 
                     // Smaller Trees: Trunk 3-5 blocks
                     if cx > 2 && cx < 13 && cz > 2 && cz < 13 {
                        // Tree
                        let th = 3 + (my_rand(&seed) % 3); // 3, 4, 5
                        for i in 0..th {
                            if h+1+i < CHUNK_HEIGHT {
                                data.blocks[cx][h+1+i][cz] = BLOCK_LOG;
                            }
                        }
                        // Leaves (Classic Minecraft Style - 5x5 at bottom, 3x3 at top)
                        let leaves_start = h + th - 2; // Start leaves 2 blocks below top
                        let leaves_end = h + th + 1;   // 1 block above top
                        
                        for ly in leaves_start..leaves_end {
                             if ly >= CHUNK_HEIGHT { continue; }
                             
                             let radius = 2;
                             if ly == leaves_end - 1 { radius = 1; } // Top layer narrower
                             if ly == leaves_end { radius = 1; } // Very top
                             
                             for lx in (cx-radius)..(cx+radius+1) {
                                 for lz in (cz-radius)..(cz+radius+1) {
                                     // Skip corners for rounded look (optional)
                                     let dx = lx - cx;
                                     let dz = lz - cz;
                                     if (dx*dx + dz*dz) > (radius*radius + 1) { continue; }
                                     
                                     if data.blocks[lx][ly][lz] == BLOCK_AIR {
                                         data.blocks[lx][ly][lz] = BLOCK_LEAVES;
                                     }
                                 }
                             }
                        }
                    }
                }
                else if r < 30 { // Tall grass chance
                    if data.plant_count < 64 {
                        data.plants[data.plant_count].x = (float)cx + 0.5;
                        data.plants[data.plant_count].y = (float)(h + 1);
                        data.plants[data.plant_count].z = (float)cz + 0.5;
                        data.plants[data.plant_count].plant_type = BLOCK_TALLGRASS;
                        data.plant_count = data.plant_count + 1;
                    }
                }
            }
        }
    }
    
    // --- Self-contained sunlight column pass (worker thread safe) ---
    // This computes proper sunlight without needing the global chunks array.
    // Shadows from trees, leaves etc. are handled correctly.
    for cx in 0..16 {
        for cz in 0..16 {
            let in_shadow = 0;
            for i in 0..CHUNK_HEIGHT {
                let cy = (CHUNK_HEIGHT - 1) - i; // Top to bottom
                let blk = data.blocks[cx][cy][cz];
                
                if !in_shadow {
                    if blk != BLOCK_AIR && blk != BLOCK_TALLGRASS && blk != BLOCK_WATER && blk != BLOCK_LEAVES {
                        // Hit solid opaque block - enters shadow
                        data.light[cx][cy][cz] = 0; // No sky light, no block light
                        in_shadow = 1;
                    } else {
                        // Sky-exposed: full sky light (15 << 4 = 240)
                        data.light[cx][cy][cz] = 240;
                    }
                } else {
                    // Underground - no sky light
                    data.light[cx][cy][cz] = 0;
                }
            }
        }
    }
    
    data.light_calculated = 1;
}


raw {
    #if defined(_WIN32)
        // Prevent Windows.h from polluting global namespace
        #define WIN32_LEAN_AND_MEAN
        #define NOGDI
        #define NOUSER
        #include <windows.h>
        
        // Undefine common collisions just in case
        #undef Near
        #undef Far
        #undef Rectangle
        #undef CloseWindow
        #undef ShowCursor
        
        HANDLE db_thread;
        DWORD WINAPI db_worker(LPVOID lpParam);
        CRITICAL_SECTION db_cs;
    #else
        #include <pthread.h>
        #include <unistd.h>
        pthread_t db_thread;
        void* db_worker(void* is_running_ptr);
        pthread_mutex_t db_mutex;
    #endif

    // The Queue
    typedef struct {
        volatile int status;
        int type;
        int cx;
        int cz;
        int target_idx;
        ChunkData data;
    } RawIORequest;

    RawIORequest io_queue[256];
    volatile int system_running = 0;
    
    // Global world directory
    char world_dir[64] = "world";

    void set_world_dir(const char* path) {
        if (!DirectoryExists(path)) {
            MakeDirectory(path);
        }
        strcpy(world_dir, path);
    }
    
    // Prototype for generator
    void generate_chunk_data(ChunkData* data, int x, int z);
    
    // Forward declare title generator (implemented elsewhere or via callback?)
    // For simplicity, we can just declare the prototype and implement it in title_generator.zc 
    // but the linker needs to see it.
    // Or we switch generator based on world_dir inside `generate_chunk_data`.
    // Actually, let's inject a generator function pointer? 
    // Zen-C doesn't support function pointers easily in high level.
    // Let's modify `generate_chunk_data` to check `world_dir`.
    
    void generate_title_chunk(ChunkData* data, int x, int z);


    // Worker Function
    #if defined(_WIN32)
    DWORD WINAPI db_worker(LPVOID lpParam)
    #else
    void* db_worker(void* arg)
    #endif
    {
        while(system_running) {
            int worked = 0;
            for(int i=0; i<256; i++) {
                if(io_queue[i].status == 1) { // IO_STATUS_PENDING
                    // Processor
                    RawIORequest *req = &io_queue[i];
                    
                    // --- REGION-BASED FILE I/O ---
                    // Region coordinates: each region holds 32x32 chunks
                    int rx = (req->cx >= 0) ? (req->cx / 32) : ((req->cx - 31) / 32);
                    int rz = (req->cz >= 0) ? (req->cz / 32) : ((req->cz - 31) / 32);
                    // Local chunk position within region (0-31)
                    int lcx = ((req->cx % 32) + 32) % 32;
                    int lcz = ((req->cz % 32) + 32) % 32;
                    
                    char region_filename[512];
                    sprintf(region_filename, "%s/region_%d_%d.zcr", world_dir, rx, rz);
                    
                    // Region file format:
                    // Header: 32*32 entries of {uint32_t offset, uint32_t size} = 8192 bytes
                    // Data: ChunkData blocks stored at their offsets
                    // offset=0 means chunk not saved yet
                    int header_entry_idx = lcz * 32 + lcx;
                    int header_size = 32 * 32 * 8; // 8192 bytes for lookup table

                    if(req->type == 1) { // SAVE
                        FILE *f = fopen(region_filename, "r+b");
                        if(!f) {
                            // Region file doesn't exist, create it
                            f = fopen(region_filename, "w+b");
                            if(f) {
                                // Write empty header
                                char zero[8192];
                                memset(zero, 0, 8192);
                                fwrite(zero, 1, 8192, f);
                            }
                        }
                        if(f) {
                            // Read current offset for this chunk
                            fseek(f, header_entry_idx * 8, SEEK_SET);
                            unsigned int offset = 0;
                            unsigned int stored_size = 0;
                            fread(&offset, 4, 1, f);
                            fread(&stored_size, 4, 1, f);
                            
                            if(offset == 0) {
                                // New chunk - append to end of file
                                fseek(f, 0, SEEK_END);
                                offset = (unsigned int)ftell(f);
                                stored_size = sizeof(ChunkData);
                                
                                // Update header entry
                                fseek(f, header_entry_idx * 8, SEEK_SET);
                                fwrite(&offset, 4, 1, f);
                                fwrite(&stored_size, 4, 1, f);
                            }
                            
                            // Write chunk data at offset
                            fseek(f, offset, SEEK_SET);
                            fwrite(&req->data, sizeof(ChunkData), 1, f);
                            fclose(f);
                        }
                        req->status = 0; // Back to FREE immediately for Save
                    }
                    else if(req->type == 2) { // LOAD
                        int loaded = 0;
                        
                        // Try region file first
                        FILE *f = fopen(region_filename, "rb");
                        if(f) {
                            // Read header entry
                            fseek(f, header_entry_idx * 8, SEEK_SET);
                            unsigned int offset = 0;
                            unsigned int stored_size = 0;
                            fread(&offset, 4, 1, f);
                            fread(&stored_size, 4, 1, f);
                            
                            if(offset > 0 && stored_size > 0) {
                                fseek(f, offset, SEEK_SET);
                                size_t rd = fread(&req->data, sizeof(ChunkData), 1, f);
                                if(rd == 1) {
                                    loaded = 1;
                                    req->data.light_calculated = 0; // Disk data needs recalc
                                }
                            }
                            fclose(f);
                        }
                        
                        // Fallback: try legacy per-chunk file
                        if(!loaded) {
                            char legacy_filename[256];
                            sprintf(legacy_filename, "%s/chunk_%d_%d.dat", world_dir, req->cx, req->cz);
                            FILE *lf = fopen(legacy_filename, "rb");
                            if(lf) {
                                size_t rd = fread(&req->data, sizeof(ChunkData), 1, lf);
                                fclose(lf);
                                if(rd == 1) {
                                    loaded = 1;
                                    req->data.light_calculated = 0; // Old format
                                }
                            }
                        }
                        
                        if(loaded) {
                            req->status = 2; // COMPLETED
                        } else {
                            // Generate new chunk
                            if(strstr(world_dir, "titleworld") != NULL) {
                                generate_title_chunk(&req->data, req->cx, req->cz);
                            } else {
                                generate_chunk_data(&req->data, req->cx, req->cz);
                            }
                            // light_calculated is set by generate_chunk_data
                            req->status = 2; // COMPLETED (Generated)
                        }
                    }
                    worked = 1;
                }
            }
            
            if(!worked) {
                // Sleep to avoid burning CPU
                #if defined(_WIN32)
                Sleep(5);
                #else
                usleep(5000);
                #endif
            }
        }
        return 0;
    }
}

fn set_game_world_dir(path: char*) {
    raw {
        set_world_dir(path);
    }
}

fn init_persistence() {
    raw {
        if (!DirectoryExists("world")) {
            MakeDirectory("world");
        }
        
        // Zero queue
        for(int i=0; i<256; i++) io_queue[i].status = 0;
        
        system_running = 1;

        #if defined(_WIN32)
            CreateThread(NULL, 0, db_worker, NULL, 0, NULL);
        #else
            pthread_create(&db_thread, NULL, db_worker, NULL);
        #endif
    }
    rl::TraceLog(rl::LOG_INFO, "Async Persistence Initialized");
}

fn request_save_async(c: Chunk*) {
    if c == NULL { return; }
    if c.x == -9999 { return; }

    raw {
        // Find free slot
        int slot = -1;
        for(int i=0; i<256; i++) {
            if(io_queue[i].status == 0) {
                slot = i;
                break;
            }
        }
        
        if(slot != -1) {
            // Setup Request
            io_queue[slot].type = 1; // SAVE
            io_queue[slot].cx = c->x;
            io_queue[slot].cz = c->z;
            io_queue[slot].target_idx = -1; // Not needed for save
            
            // Copy Data
            memcpy(io_queue[slot].data.blocks, c->blocks, sizeof(io_queue[slot].data.blocks));
            memcpy(io_queue[slot].data.light, c->light, sizeof(io_queue[slot].data.light));
            io_queue[slot].data.plant_count = c->plant_count;
            memcpy(io_queue[slot].data.plants, c->plants, sizeof(io_queue[slot].data.plants));
            
            // Commit
            io_queue[slot].status = 1; // PENDING
        } else {
            TraceLog(LOG_WARNING, "Async Save Queue Full!");
        }
    }
}

fn request_load_async(idx: int, cx: int, cz: int) -> int {
    let result = 0;
    raw {
        // Find free slot
        int slot = -1;
        for(int i=0; i<256; i++) {
            if(io_queue[i].status == 0) {
                slot = i;
                break;
            }
        }
        
        if(slot != -1) {
            io_queue[slot].type = 2; // LOAD
            io_queue[slot].cx = cx;
            io_queue[slot].cz = cz;
            io_queue[slot].target_idx = idx;
            io_queue[slot].status = 1; // PENDING
            result = 1;
        }
    }
    return result;
}

// Check if a chunk load request is already pending for the given coordinates
fn is_chunk_pending(cx: int, cz: int) -> int {
    let result = 0;
    raw {
        for(int i=0; i<256; i++) {
            if((io_queue[i].status == 1 || io_queue[i].status == 2) && 
               io_queue[i].type == 2 &&
               io_queue[i].cx == cx && io_queue[i].cz == cz) {
                result = 1;
                break;
            }
        }
    }
    return result;
}

// Returns 1 if chunk was loaded/generated this frame
fn poll_async_results(chunks: Chunk*, num_chunks: int) {
    raw {
        int processed_count = 0;
        // Process up to 4 completed chunks per frame for faster loading
        // while still limiting main-thread work
        int max_per_frame = 4;
        
        for(int i=0; i<256; i++) {
            if(io_queue[i].status == 2) { // COMPLETED LOAD (or Generated)
                if(processed_count >= max_per_frame) break;

                int idx = io_queue[i].target_idx;
                if(idx >= 0 && idx < num_chunks) {
                    // Apply Data
                    chunks[idx].x = io_queue[i].cx;
                    chunks[idx].z = io_queue[i].cz;
                    
                    memcpy(chunks[idx].blocks, io_queue[i].data.blocks, sizeof(chunks[idx].blocks));
                    memcpy(chunks[idx].light, io_queue[i].data.light, sizeof(chunks[idx].light));
                    chunks[idx].plant_count = io_queue[i].data.plant_count;
                    memcpy(chunks[idx].plants, io_queue[i].data.plants, sizeof(chunks[idx].plants));
                    
                    chunks[idx].mesh_dirty = 1;
                    chunks[idx].mesh_built = 0;
                    chunks[idx].plant_mesh_built = 0;
                    chunks[idx].grass_deco_built = 0;
                    
                    // Lighting optimization:
                    // If the worker already computed sunlight columns (generated chunks),
                    // skip the expensive full recalculation and only do cross-chunk propagation.
                    // For loaded-from-disk chunks, we still need full recalc.
                    if(io_queue[i].data.light_calculated) {
                        // Worker did sunlight - just propagate across chunk boundaries
                        propagate_light_in_chunk(&chunks[idx], chunks, num_chunks);
                    } else {
                        // Loaded from disk (old save) - full recalculation needed
                        recalculate_chunk_lighting(&chunks[idx], chunks, num_chunks);
                        propagate_light_in_chunk(&chunks[idx], chunks, num_chunks);
                    }
                    
                    // Mark neighbor chunks as dirty so they rebuild border faces
                    int cx = chunks[idx].x;
                    int cz = chunks[idx].z;
                    
                    int neighbor_offsets[8] = {-1, 0, 1, 0, 0, -1, 0, 1};
                    for(int ni = 0; ni < 4; ni++) {
                        int ncx = cx + neighbor_offsets[ni * 2];
                        int ncz = cz + neighbor_offsets[ni * 2 + 1];
                        int nidx = get_chunk_index(ncx, ncz);
                        
                        if(chunks[nidx].x == ncx && chunks[nidx].z == ncz) {
                            // Re-propagate light across boundary
                            propagate_light_in_chunk(&chunks[nidx], chunks, num_chunks);
                            chunks[nidx].mesh_dirty = 1;
                        }
                    }
                    
                    processed_count++;
                }
                io_queue[i].status = 0; // Free
            }
            // Status 3 (FAILED) is now handled in thread by generating
        }
    }
}

// --- Player Persistence ---

struct PlayerSaveData {
    x: float;
    y: float;
    z: float;
    selected_block: int;
    yaw: float;
    pitch: float;
}

fn save_player_data(x: float, y: float, z: float, block: int, yaw: float, pitch: float) {
    raw {
        if (!DirectoryExists(world_dir)) MakeDirectory(world_dir);
        
        PlayerSaveData pd;
        pd.x = x;
        pd.y = y;
        pd.z = z;
        pd.selected_block = block;
        pd.yaw = yaw;
        pd.pitch = pitch;
        
        TraceLog(LOG_INFO, "Saving Player: %.2f, %.2f, %.2f, Yaw: %.2f, Pitch: %.2f, Block: %d", x, y, z, yaw, pitch, block);
        
        char filename[256];
        sprintf(filename, "%s/player.dat", world_dir);
        
        FILE *f = fopen(filename, "wb");
        if(f) {
            fwrite(&pd, sizeof(PlayerSaveData), 1, f);
            fclose(f);
            TraceLog(LOG_INFO, "Player data saved successfully.");
        } else {
            TraceLog(LOG_ERROR, "Failed to open world/player.dat for writing.");
        }
    }
}

fn load_player_data(x: float*, y: float*, z: float*, block: int*, yaw: float*, pitch: float*) -> int {
    let success = 0;
    raw {
        char filename[256];
        sprintf(filename, "%s/player.dat", world_dir);
        
        FILE *f = fopen(filename, "rb");
        if(f) {
            PlayerSaveData pd;
            size_t read = fread(&pd, sizeof(PlayerSaveData), 1, f);
            if(read == 1) {
                *x = pd.x;
                *y = pd.y;
                *z = pd.z;
                *block = pd.selected_block;
                *yaw = pd.yaw;
                *pitch = pd.pitch;
                success = 1;
                TraceLog(LOG_INFO, "Player data loaded: %.2f, %.2f, %.2f, Yaw: %.2f, Pitch: %.2f, Block: %d", 
                         pd.x, pd.y, pd.z, pd.yaw, pd.pitch, pd.selected_block);
            } else {
                TraceLog(LOG_WARNING, "Failed to read player data. Read count: %d", read);
            }
            fclose(f);
        } else {
             TraceLog(LOG_INFO, "No player data found (New Game).");
        }
    }
    return success;
}

// Synchronous load - try to load from disk, generate if file doesn't exist
fn load_chunk_into(c: Chunk*, cx: int, cz: int) {
    // Initialize defaults 
    // We can't call Chunk::new because that returns a value on stack (potentially large copy)
    // and we want to write into existing pointer.
    // Chunk init logic:
    c.x = cx;
    c.z = cz;
    c.mesh_built = 0;
    c.plant_mesh_built = 0;
    c.grass_deco_built = 0;
    c.water_mesh_built = 0;
    c.plant_count = 0;
    
    // We need to generate data if load fails
    // But generating directly into `c` is tricky if we use `generate_chunk_data` which takes `ChunkData*`.
    // `Chunk` structure matches `ChunkData` structure generally?
    // `ChunkData` has `blocks`, `light`, ...
    // `Chunk` has `blocks`, `light`...
    // They are compatible in layout?
    // `ChunkData` struct: blocks[16][256][16], light, plant_count, plants.
    // `Chunk` struct: x, z, ... blocks, light ... plants.
    // They are NOT identical layout. `Chunk` has headers.
    
    // So we need `ChunkData` temp. 
    // ALLOCATE ON HEAP to avoid stack overflow.
    
    raw {
        ChunkData* data_ptr = (ChunkData*)malloc(sizeof(ChunkData));
        if (data_ptr == NULL) return; // Should handle error
        
        char filename[256];
        sprintf(filename, "%s/chunk_%d_%d.dat", world_dir, cx, cz);
        
        int loaded = 0;
        FILE *f = fopen(filename, "rb");
        if(f) {
            size_t read = fread(data_ptr, sizeof(ChunkData), 1, f);
            fclose(f);
            if(read == 1) loaded = 1;
        }
        
        if (!loaded) {
            // Generate
            if(strstr(world_dir, "titleworld") != NULL) {
                generate_title_chunk(data_ptr, cx, cz);
            } else {
                generate_chunk_data(data_ptr, cx, cz);
            }
        }
        
        // Copy to Chunk
        // Access c->blocks via pointer
        memcpy(c->blocks, data_ptr->blocks, sizeof(c->blocks));
        memcpy(c->light, data_ptr->light, sizeof(c->light));
        c->plant_count = data_ptr->plant_count;
        memcpy(c->plants, data_ptr->plants, sizeof(c->plants));
        
        free(data_ptr);
    }
    
    // Recalculate lighting only if loaded? Or always?
    // Generated chunks have light set by generator.
    // Loaded chunks might need fix (old bug).
    // Let's safe side: recalculate. Or maybe just propagate.
    // For now, assume loaded/generated is close enough.
    // Using `recalculate_chunk_lighting` is heavy.
}

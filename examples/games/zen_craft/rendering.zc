//> This file contains rendering-related functions and asset loading

import "raylib.h" as rl;
import "rlgl.h";

// Screen configuration
def SCREEN_WIDTH = 1920;
def SCREEN_HEIGHT = 1080;
def TITLE = "Zen Craft";

// Global textures and shaders
let tex_atlas: rl::Texture2D;
let tex_grass: rl::Texture2D;
let tex_sun: rl::Texture2D;
let tex_moon: rl::Texture2D;
let sh_lighting: rl::Shader;

// Uniform Locations
let loc_light_dir: int;
let loc_light_col: int;
let loc_ambient: int;

fn load_texture_from_memory(_data: char*, _len: int) -> rl::Texture2D {
    let tex: rl::Texture2D;
    raw {
        Image img = LoadImageFromMemory(".png", (unsigned char*)_data, _len);
        tex = LoadTextureFromImage(img);
        SetTextureFilter(tex, TEXTURE_FILTER_POINT);
        UnloadImage(img);
    }
    return tex;
}

fn load_shader_from_memory(_vs: char*, _vs_len: int, _fs: char*, _fs_len: int) -> rl::Shader {
    let sh: rl::Shader;
    raw {
        char* vs = (char*)MemAlloc(_vs_len + 1);
        memcpy(vs, _vs, _vs_len);
        vs[_vs_len] = '\0';

        char* fs = (char*)MemAlloc(_fs_len + 1);
        memcpy(fs, _fs, _fs_len);
        fs[_fs_len] = '\0';

        sh = LoadShaderFromMemory(vs, fs);

        MemFree(vs);
        MemFree(fs);
    }
    return sh;
}

fn init_textures() {
    // Load individual images
    let dirt_data = embed "./assets/dirt.png";
    let grass_side_data = embed "./assets/grass_side.png";
    let grass_top_data = embed "./assets/grass.png";
    let stone_data = embed "./assets/stone.png";
    let log_data = embed "./assets/log.png";
    let leaves_data = embed "./assets/leaves.png";
    
    let sun_data = embed "./assets/sun.png";
    let moon_data = embed "./assets/moon.png";
    let plant_data = embed "./assets/hierba_sprite.png";
    
    let vs_data = embed "./assets/lighting.vs";
    let fs_data = embed "./assets/lighting.fs";

    // Create Atlas Programmatically (4 cols x 2 rows)
    // Col 0: Dirt, Grass_Side
    // Col 1: Grass_Top, Stone
    // Col 2: Log, Leaves
    // Col 3: Log_Top(Log), (Empty)
    
    // Original images are likely square. Assume 16x16 or similar.
    // We'll load them as Images, verify size, then draw onto atlas.
    
    raw {
        Image img_dirt = LoadImageFromMemory(".png", (unsigned char*)dirt_data.data, dirt_data.len);
        Image img_grass_s = LoadImageFromMemory(".png", (unsigned char*)grass_side_data.data, grass_side_data.len);
        Image img_grass_t = LoadImageFromMemory(".png", (unsigned char*)grass_top_data.data, grass_top_data.len);
        Image img_stone = LoadImageFromMemory(".png", (unsigned char*)stone_data.data, stone_data.len);
        Image img_log = LoadImageFromMemory(".png", (unsigned char*)log_data.data, log_data.len);
        Image img_leaves = LoadImageFromMemory(".png", (unsigned char*)leaves_data.data, leaves_data.len);
        
        int w = img_dirt.width;
        int h = img_dirt.height;
        
        // Create Atlas: 4 * w, 2 * h
        Image atlas = GenImageColor(w * 4, h * 2, BLANK);
        
        // Row 0 (Top half)
        // (0,0) Dirt
        ImageDraw(&atlas, img_dirt, (Rectangle){0,0,w,h}, (Rectangle){0,0,w,h}, WHITE);
        // (1,0) Grass Top
        ImageDraw(&atlas, img_grass_t, (Rectangle){0,0,w,h}, (Rectangle){w,0,w,h}, WHITE);
        // (2,0) Log Side
        ImageDraw(&atlas, img_log, (Rectangle){0,0,w,h}, (Rectangle){w*2,0,w,h}, WHITE);
        // (3,0) Log Top (reuse log side for now)
        ImageDraw(&atlas, img_log, (Rectangle){0,0,w,h}, (Rectangle){w*3,0,w,h}, WHITE);
        
        // Row 1 (Bottom half)
        // (0,1) Grass Side
        ImageDraw(&atlas, img_grass_s, (Rectangle){0,0,w,h}, (Rectangle){0,h,w,h}, WHITE);
        // (1,1) Stone
        ImageDraw(&atlas, img_stone, (Rectangle){0,0,w,h}, (Rectangle){w,h,w,h}, WHITE);
        // (2,1) Leaves
        ImageDraw(&atlas, img_leaves, (Rectangle){0,0,w,h}, (Rectangle){w*2,h,w,h}, WHITE);
        
        // (3,1) Torch (Procedural) - Fill entire tile
        // Background: dark brown/black for the stick
        ImageDrawRectangle(&atlas, w*3, h, w, h, (Color){40, 30, 20, 255}); // Dark brown background
        
        // Main stick body (fills most of the texture)
        ImageDrawRectangle(&atlas, w*3 + 2, h + 4, w-4, h-8, (Color){101, 67, 33, 255}); // Brown stick
        
        // Flame at top (upper 1/3 of texture)
        ImageDrawRectangle(&atlas, w*3 + 3, h + 2, w-6, 6, ORANGE); // Orange flame
        ImageDrawRectangle(&atlas, w*3 + 4, h + 1, w-8, 3, YELLOW); // Yellow core
        
        tex_atlas = LoadTextureFromImage(atlas);
        SetTextureFilter(tex_atlas, TEXTURE_FILTER_POINT);
        
        // Cleanup
        UnloadImage(img_dirt);
        UnloadImage(img_grass_s);
        UnloadImage(img_grass_t);
        UnloadImage(img_stone);
        UnloadImage(img_log);
        UnloadImage(img_leaves);
        UnloadImage(atlas);
    }

    tex_grass = load_texture_from_memory(plant_data.data, plant_data.len);
    tex_sun = load_texture_from_memory(sun_data.data, sun_data.len);
    tex_moon = load_texture_from_memory(moon_data.data, moon_data.len);
    
    sh_lighting = load_shader_from_memory(vs_data.data, vs_data.len, fs_data.data, fs_data.len);

    // Get Uniform Locations
    raw {
        loc_light_dir = GetShaderLocation(sh_lighting, "uLightDir");
        loc_light_col = GetShaderLocation(sh_lighting, "uLightCol");
        loc_ambient = GetShaderLocation(sh_lighting, "uAmbient");
        
        // Set default values (Mid-day)
        Vector3 d = {0.8f, 1.0f, 0.5f};
        Vector3 c = {0.9f, 0.9f, 0.85f};
        Vector3 a = {0.5f, 0.5f, 0.55f};
        SetShaderValue(sh_lighting, loc_light_dir, &d, SHADER_UNIFORM_VEC3);
        SetShaderValue(sh_lighting, loc_light_col, &c, SHADER_UNIFORM_VEC3);
        SetShaderValue(sh_lighting, loc_ambient, &a, SHADER_UNIFORM_VEC3);
    }

    // No longer need individual models - chunks build their own meshes
}

fn update_lighting_uniforms(dir: rl::Vector3, col: rl::Vector3, amb: rl::Vector3) {
    raw {
        SetShaderValue(sh_lighting, loc_light_dir, &dir, SHADER_UNIFORM_VEC3);
        SetShaderValue(sh_lighting, loc_light_col, &col, SHADER_UNIFORM_VEC3);
        SetShaderValue(sh_lighting, loc_ambient, &amb, SHADER_UNIFORM_VEC3);
    }
}

fn get_tex_atlas() -> rl::Texture2D {
    return tex_atlas;
}

fn get_tex_grass() -> rl::Texture2D {
    return tex_grass;
}

fn get_shader_lighting() -> rl::Shader {
    return sh_lighting;
}

fn update_day_night_cycle(day_time: float) {
    // day_time: 0.0 (Amanecer) -> 0.25 (Mediodía) -> 0.5 (Atardecer) -> 0.75 (Medianoche) -> 1.0 (Amanecer)
    
    // 1. Calcular Dirección del Sol (Continua)
    let angle = (day_time * 2.0 * 3.14159) - 3.14159/2.0;
    let sun_y = (float)sin(angle);
    let sun_x = (float)cos(angle);
    
    let dir = rl::Vector3{ x: sun_x, y: sun_y, z: 0.2f };

    // 2. Interpolación Suave de Color y Ambiente
    // Definimos colores clave en puntos específicos del día
    // Dawn (0.0):    col=(1.0, 0.6, 0.3), amb=(0.15, 0.12, 0.1)
    // Noon (0.25):   col=(1.0, 1.0, 0.95), amb=(0.5, 0.5, 0.5)
    // Sunset (0.5):  col=(1.0, 0.5, 0.2), amb=(0.2, 0.15, 0.1)
    // Midnight (0.75): col=(0.1, 0.1, 0.2), amb=(0.05, 0.05, 0.08)
    
    let col = rl::Vector3{x: 1.0, y: 1.0, z: 1.0};
    let amb = rl::Vector3{x: 0.3, y: 0.3, z: 0.3};
    
    if day_time < 0.25 {
        // Dawn -> Noon (0.0 to 0.25)
        let t = day_time / 0.25; // 0..1
        col.x = 1.0;
        col.y = 0.6 + t * 0.4;   // 0.6 -> 1.0
        col.z = 0.3 + t * 0.65;  // 0.3 -> 0.95
        
        amb.x = 0.1 + t * 0.2;   // 0.1 -> 0.3
        amb.y = 0.08 + t * 0.22; // 0.08 -> 0.3
        amb.z = 0.06 + t * 0.24; // 0.06 -> 0.3
    }
    else if day_time < 0.5 {
        // Noon -> Sunset (0.25 to 0.5)
        let t = (day_time - 0.25) / 0.25; // 0..1
        col.x = 1.0;
        col.y = 1.0 - t * 0.5;   // 1.0 -> 0.5
        col.z = 0.95 - t * 0.75; // 0.95 -> 0.2
        
        amb.x = 0.3 - t * 0.15;  // 0.3 -> 0.15
        amb.y = 0.3 - t * 0.18;  // 0.3 -> 0.12
        amb.z = 0.3 - t * 0.22;  // 0.3 -> 0.08
    }
    else if day_time < 0.75 {
        // Sunset -> Midnight (0.5 to 0.75)
        let t = (day_time - 0.5) / 0.25; // 0..1
        col.x = 1.0 - t * 0.98;  // 1.0 -> 0.02
        col.y = 0.5 - t * 0.47;  // 0.5 -> 0.03
        col.z = 0.2 - t * 0.15;  // 0.2 -> 0.05 (slight blue tint)
        
        amb.x = 0.15 - t * 0.14; // 0.15 -> 0.01
        amb.y = 0.12 - t * 0.11; // 0.12 -> 0.01
        amb.z = 0.08 - t * 0.06; // 0.08 -> 0.02
    }
    else {
        // Midnight -> Dawn (0.75 to 1.0)
        let t = (day_time - 0.75) / 0.25; // 0..1
        col.x = 0.02 + t * 0.98; // 0.02 -> 1.0
        col.y = 0.03 + t * 0.57; // 0.03 -> 0.6
        col.z = 0.05 + t * 0.25; // 0.05 -> 0.3
        
        amb.x = 0.01 + t * 0.09; // 0.01 -> 0.1
        amb.y = 0.01 + t * 0.07; // 0.01 -> 0.08
        amb.z = 0.02 + t * 0.04; // 0.02 -> 0.06
    }

    // Actualizar los shaders
    update_lighting_uniforms(dir, col, amb);
}

fn draw_sky(camera: rl::Camera3D, day_time: float) {
    // Disable Depth Mask to draw sky behind everything
    rl::BeginMode3D(camera);
        
        // Calculate orbit
        // 0.25 = Noon (Top), 0.5 = Sunset, 0.75 = Midnight, 0.0 = Sunrise
        // Radius 50
        
        let sun_angle = (day_time * 2.0 * 3.14159) - 3.14159/2.0;

        let sun_pos = rl::Vector3{
            x: camera.position.x + (float)cos(sun_angle) * 50.0, 
            y: camera.position.y + (float)sin(sun_angle) * 50.0, 
            z: camera.position.z + 10.0
        };
        
        // Moon is opposite
        let moon_pos = rl::Vector3{
            x: camera.position.x - (float)cos(sun_angle) * 50.0, 
            y: camera.position.y - (float)sin(sun_angle) * 50.0, 
            z: camera.position.z - 10.0
        };

        raw {
            // Draw Sun
            DrawBillboard(camera, tex_sun, sun_pos, 15.0f, WHITE);
            
            // Draw Moon
            DrawBillboard(camera, tex_moon, moon_pos, 12.0f, WHITE);
        }
    rl::EndMode3D();
}

//> This file contains rendering-related functions and asset loading

import "raylib.h" as rl;
import "rlgl.h";

// Screen configuration
def SCREEN_WIDTH = 1920;
def SCREEN_HEIGHT = 1080;
def TITLE = "Zen Craft";

// Global textures and shaders
let tex_atlas: rl::Texture2D;
let tex_grass: rl::Texture2D;
let tex_sun: rl::Texture2D;
let tex_moon: rl::Texture2D;
let sh_lighting: rl::Shader;

// Uniform Locations
let loc_light_dir: int;
let loc_light_col: int;
let loc_ambient: int;

fn load_texture_from_memory(_data: char*, _len: int) -> rl::Texture2D {
    let tex: rl::Texture2D;
    raw {
        Image img = LoadImageFromMemory(".png", (unsigned char*)_data, _len);
        tex = LoadTextureFromImage(img);
        SetTextureFilter(tex, TEXTURE_FILTER_POINT);
        UnloadImage(img);
    }
    return tex;
}

fn load_shader_from_memory(_vs: char*, _vs_len: int, _fs: char*, _fs_len: int) -> rl::Shader {
    let sh: rl::Shader;
    raw {
        char* vs = (char*)MemAlloc(_vs_len + 1);
        memcpy(vs, _vs, _vs_len);
        vs[_vs_len] = '\0';

        char* fs = (char*)MemAlloc(_fs_len + 1);
        memcpy(fs, _fs, _fs_len);
        fs[_fs_len] = '\0';

        sh = LoadShaderFromMemory(vs, fs);

        MemFree(vs);
        MemFree(fs);
    }
    return sh;
}

fn init_textures() {
    // Load individual images
    let dirt_data = embed "./assets/dirt.png";
    let grass_side_data = embed "./assets/grass_side.png";
    let grass_top_data = embed "./assets/grass.png";
    let stone_data = embed "./assets/stone.png";
    let log_data = embed "./assets/log.png";
    let leaves_data = embed "./assets/leaves.png";
    
    let sun_data = embed "./assets/sun.png";
    let moon_data = embed "./assets/moon.png";
    let plant_data = embed "./assets/hierba_sprite.png";
    
    let vs_data = embed "./assets/lighting.vs";
    let fs_data = embed "./assets/lighting.fs";

    // Create Atlas Programmatically (4 cols x 2 rows)
    // Col 0: Dirt, Grass_Side
    // Col 1: Grass_Top, Stone
    // Col 2: Log, Leaves
    // Col 3: Log_Top(Log), (Empty)
    
    // Original images are likely square. Assume 16x16 or similar.
    // We'll load them as Images, verify size, then draw onto atlas.
    
    raw {
        Image img_dirt = LoadImageFromMemory(".png", (unsigned char*)dirt_data.data, dirt_data.len);
        Image img_grass_s = LoadImageFromMemory(".png", (unsigned char*)grass_side_data.data, grass_side_data.len);
        Image img_grass_t = LoadImageFromMemory(".png", (unsigned char*)grass_top_data.data, grass_top_data.len);
        Image img_stone = LoadImageFromMemory(".png", (unsigned char*)stone_data.data, stone_data.len);
        Image img_log = LoadImageFromMemory(".png", (unsigned char*)log_data.data, log_data.len);
        Image img_leaves = LoadImageFromMemory(".png", (unsigned char*)leaves_data.data, leaves_data.len);
        
        int w = img_dirt.width;
        int h = img_dirt.height;
        
        // Create Atlas: 4 * w, 2 * h
        Image atlas = GenImageColor(w * 4, h * 2, BLANK);
        
        // Row 0 (Top half)
        // (0,0) Dirt
        ImageDraw(&atlas, img_dirt, (Rectangle){0,0,w,h}, (Rectangle){0,0,w,h}, WHITE);
        // (1,0) Grass Top
        ImageDraw(&atlas, img_grass_t, (Rectangle){0,0,w,h}, (Rectangle){w,0,w,h}, WHITE);
        // (2,0) Log Side
        ImageDraw(&atlas, img_log, (Rectangle){0,0,w,h}, (Rectangle){w*2,0,w,h}, WHITE);
        // (3,0) Log Top (reuse log side for now)
        ImageDraw(&atlas, img_log, (Rectangle){0,0,w,h}, (Rectangle){w*3,0,w,h}, WHITE);
        
        // Row 1 (Bottom half)
        // (0,1) Grass Side
        ImageDraw(&atlas, img_grass_s, (Rectangle){0,0,w,h}, (Rectangle){0,h,w,h}, WHITE);
        // (1,1) Stone
        ImageDraw(&atlas, img_stone, (Rectangle){0,0,w,h}, (Rectangle){w,h,w,h}, WHITE);
        // (2,1) Leaves
        ImageDraw(&atlas, img_leaves, (Rectangle){0,0,w,h}, (Rectangle){w*2,h,w,h}, WHITE);
        
        // (3,1) Torch (Procedural) - Fill entire tile
        // Background: dark brown/black for the stick
        ImageDrawRectangle(&atlas, w*3, h, w, h, (Color){40, 30, 20, 255}); // Dark brown background
        
        // Main stick body (fills most of the texture)
        ImageDrawRectangle(&atlas, w*3 + 2, h + 4, w-4, h-8, (Color){101, 67, 33, 255}); // Brown stick
        
        // Flame at top (upper 1/3 of texture)
        ImageDrawRectangle(&atlas, w*3 + 3, h + 2, w-6, 6, ORANGE); // Orange flame
        ImageDrawRectangle(&atlas, w*3 + 4, h + 1, w-8, 3, YELLOW); // Yellow core
        
        tex_atlas = LoadTextureFromImage(atlas);
        SetTextureFilter(tex_atlas, TEXTURE_FILTER_POINT);
        
        // Cleanup
        UnloadImage(img_dirt);
        UnloadImage(img_grass_s);
        UnloadImage(img_grass_t);
        UnloadImage(img_stone);
        UnloadImage(img_log);
        UnloadImage(img_leaves);
        UnloadImage(atlas);
    }

    tex_grass = load_texture_from_memory(plant_data.data, plant_data.len);
    tex_sun = load_texture_from_memory(sun_data.data, sun_data.len);
    tex_moon = load_texture_from_memory(moon_data.data, moon_data.len);
    
    sh_lighting = load_shader_from_memory(vs_data.data, vs_data.len, fs_data.data, fs_data.len);

    // Get Uniform Locations
    raw {
        loc_light_dir = GetShaderLocation(sh_lighting, "uLightDir");
        loc_light_col = GetShaderLocation(sh_lighting, "uLightCol");
        loc_ambient = GetShaderLocation(sh_lighting, "uAmbient");
        
        // Set default values (Mid-day)
        Vector3 d = {0.8f, 1.0f, 0.5f};
        Vector3 c = {0.9f, 0.9f, 0.85f};
        Vector3 a = {0.5f, 0.5f, 0.55f};
        SetShaderValue(sh_lighting, loc_light_dir, &d, SHADER_UNIFORM_VEC3);
        SetShaderValue(sh_lighting, loc_light_col, &c, SHADER_UNIFORM_VEC3);
        SetShaderValue(sh_lighting, loc_ambient, &a, SHADER_UNIFORM_VEC3);
    }

    // No longer need individual models - chunks build their own meshes
}

fn update_lighting_uniforms(dir: rl::Vector3, col: rl::Vector3, amb: rl::Vector3) {
    raw {
        SetShaderValue(sh_lighting, loc_light_dir, &dir, SHADER_UNIFORM_VEC3);
        SetShaderValue(sh_lighting, loc_light_col, &col, SHADER_UNIFORM_VEC3);
        SetShaderValue(sh_lighting, loc_ambient, &amb, SHADER_UNIFORM_VEC3);
    }
}

fn get_tex_atlas() -> rl::Texture2D {
    return tex_atlas;
}

fn get_tex_grass() -> rl::Texture2D {
    return tex_grass;
}

fn get_shader_lighting() -> rl::Shader {
    return sh_lighting;
}

fn draw_sky(camera: rl::Camera3D, day_time: float) {
    // Disable Depth Mask to draw sky behind everything
    rl::BeginMode3D(camera);
        
        // Calculate orbit
        // 0.25 = Noon (Top), 0.5 = Sunset, 0.75 = Midnight, 0.0 = Sunrise
        // Radius 50
        
        let sun_angle = (day_time * 2.0 * 3.14159) - 3.14159/2.0;

        let sun_pos = rl::Vector3{
            x: camera.position.x + (float)cos(sun_angle) * 50.0, 
            y: camera.position.y + (float)sin(sun_angle) * 50.0, 
            z: camera.position.z + 10.0
        };
        
        // Moon is opposite
        let moon_pos = rl::Vector3{
            x: camera.position.x - (float)cos(sun_angle) * 50.0, 
            y: camera.position.y - (float)sin(sun_angle) * 50.0, 
            z: camera.position.z - 10.0
        };

        raw {
            // Draw Sun
            DrawBillboard(camera, tex_sun, sun_pos, 15.0f, WHITE);
            
            // Draw Moon
            DrawBillboard(camera, tex_moon, moon_pos, 12.0f, WHITE);
        }
    rl::EndMode3D();
}

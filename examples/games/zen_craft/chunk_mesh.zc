//> This file contains the chunk mesh building implementation

import "raylib.h" as rl; 
import "rlgl.h";
import "blocks.zc";
import "chunk.zc";
import "rendering.zc";

// Use a local macro to be 100% sure BLOCK_WATER (8) is included and no import issues occur
#define IS_TRANSPARENT_MESH(b) ((b) == 0 || ((b) >= 10 && (b) <= 14) || (b) == 4 || (b) == 6 || (b) == 8)

// --- Compute Functions (Thread Safe - CPU Only) ---

fn compute_chunk_mesh(c: Chunk*, chunks: Chunk*, num_chunks: int) -> ChunkMeshes {
    let res: ChunkMeshes;
    raw {
        res.has_opaque = 0;
        res.has_water = 0;
        
        int gx_base = c->x * 16;
        int gz_base = c->z * 16;

        // Count visible faces first to allocate exact size
        int face_count = 0;
        int water_face_count = 0;
        
        for (int x = 0; x < 16; x++) {
            for (int y = 0; y < CHUNK_HEIGHT; y++) {
                for (int z = 0; z < 16; z++) {
                    int btype = c->blocks[x][y][z];
                    if (btype == BLOCK_AIR) continue;
                    
                    int b_gx = gx_base + x;
                    int b_gz = gz_base + z;

                    // Check each face for solid blocks
                    if (btype >= 10 && btype <= 14) {
                        // Torches: Always count 6 faces (safe estimate)
                        face_count = face_count + 6;
                        continue;
                    }
                    
                    // Count water faces separately
                    if (btype == BLOCK_WATER) {
                        int neighbor_above = get_block(chunks, num_chunks, b_gx, y + 1, b_gz);
                        if (neighbor_above != BLOCK_WATER && IS_TRANSPARENT_MESH(neighbor_above)) {
                            water_face_count++;
                        }
                        continue;
                    }

                    // Check neighbors. Must match SHOULD_RENDER_FACE logic!
                    if (IS_TRANSPARENT_MESH(get_block(chunks, num_chunks, b_gx + 1, y, b_gz))) face_count++; // +X
                    if (IS_TRANSPARENT_MESH(get_block(chunks, num_chunks, b_gx - 1, y, b_gz))) face_count++; // -X
                    if (IS_TRANSPARENT_MESH(get_block(chunks, num_chunks, b_gx, y + 1, b_gz))) face_count++; // +Y
                    if (IS_TRANSPARENT_MESH(get_block(chunks, num_chunks, b_gx, y - 1, b_gz))) face_count++; // -Y
                    if (IS_TRANSPARENT_MESH(get_block(chunks, num_chunks, b_gx, y, b_gz + 1))) face_count++; // +Z
                    if (IS_TRANSPARENT_MESH(get_block(chunks, num_chunks, b_gx, y, b_gz - 1))) face_count++; // -Z
                }
            }
        }
        
        if (face_count == 0 && water_face_count == 0) {
            // Empty - return empty result
            // has_opaque = 0
            return res; 
        }
        
        // Allocate vertex data
        int vertex_count = face_count * 6;
        int w_vertex_count = water_face_count * 6;
        
        // Opaque Mesh Arrays
        float* vertices = NULL;
        float* normals = NULL;
        float* texcoords = NULL;
        unsigned char* colors = NULL;
        
        if (vertex_count > 0) {
            vertices = (float*)malloc(vertex_count * 3 * sizeof(float));
            normals = (float*)malloc(vertex_count * 3 * sizeof(float));
            texcoords = (float*)malloc(vertex_count * 2 * sizeof(float));
            colors = (unsigned char*)malloc(vertex_count * 4 * sizeof(unsigned char));
        }
        
        // Water Mesh Arrays
        float* w_vertices = NULL;
        float* w_normals = NULL;
        float* w_texcoords = NULL;
        unsigned char* w_colors = NULL;
        
        if (w_vertex_count > 0) {
            w_vertices = (float*)malloc(w_vertex_count * 3 * sizeof(float));
            w_normals = (float*)malloc(w_vertex_count * 3 * sizeof(float));
            w_texcoords = (float*)malloc(w_vertex_count * 2 * sizeof(float));
            w_colors = (unsigned char*)malloc(w_vertex_count * 4 * sizeof(unsigned char));
        }

        int v_idx = 0;
        int w_v_idx = 0;
        
        // Quad Buffer
        float q_px[4]; float q_py[4]; float q_pz[4];
        float q_nx[4]; float q_ny[4]; float q_nz[4];
        float q_u[4]; float q_v[4];
        int q_light[4];
        int q_flag[4];
        int q_idx = 0;

        // Helper macro to buffer vertex
        #define ADD_VERTEX_GENERIC(px, py, pz, nx, ny, nz, u, v, light_val, IS_WATER) \
            q_px[q_idx] = (float)(px); \
            q_py[q_idx] = (float)(py); \
            q_pz[q_idx] = (float)(pz); \
            q_nx[q_idx] = nx; \
            q_ny[q_idx] = ny; \
            q_nz[q_idx] = nz; \
            q_u[q_idx] = u; \
            q_v[q_idx] = v; \
            q_light[q_idx] = light_val; \
            if (IS_WATER) q_flag[q_idx] = 255; else q_flag[q_idx] = current_flag; \
            q_idx++;

        // Helper macro to emit one final vertex from buffer
        #define EMIT_VERTEX(idx, IS_WATER) \
            if (IS_WATER) { \
                w_vertices[w_v_idx * 3 + 0] = q_px[idx]; \
                w_vertices[w_v_idx * 3 + 1] = q_py[idx]; \
                w_vertices[w_v_idx * 3 + 2] = q_pz[idx]; \
                w_normals[w_v_idx * 3 + 0] = q_nx[idx]; \
                w_normals[w_v_idx * 3 + 1] = q_ny[idx]; \
                w_normals[w_v_idx * 3 + 2] = q_nz[idx]; \
                w_texcoords[w_v_idx * 2 + 0] = q_u[idx]; \
                w_texcoords[w_v_idx * 2 + 1] = q_v[idx]; \
                w_colors[w_v_idx * 4 + 0] = ((q_light[idx] & 0xF) * 17); \
                w_colors[w_v_idx * 4 + 1] = (((q_light[idx] >> 4) & 0xF) * 17); \
                w_colors[w_v_idx * 4 + 2] = 255; \
                w_colors[w_v_idx * 4 + 3] = 255; \
                w_v_idx++; \
            } else { \
                vertices[v_idx * 3 + 0] = q_px[idx]; \
                vertices[v_idx * 3 + 1] = q_py[idx]; \
                vertices[v_idx * 3 + 2] = q_pz[idx]; \
                normals[v_idx * 3 + 0] = q_nx[idx]; \
                normals[v_idx * 3 + 1] = q_ny[idx]; \
                normals[v_idx * 3 + 2] = q_nz[idx]; \
                texcoords[v_idx * 2 + 0] = q_u[idx]; \
                texcoords[v_idx * 2 + 1] = q_v[idx]; \
                colors[v_idx * 4 + 0] = ((q_light[idx] & 0xF) * 17); \
                colors[v_idx * 4 + 1] = (((q_light[idx] >> 4) & 0xF) * 17); \
                colors[v_idx * 4 + 2] = q_flag[idx]; \
                colors[v_idx * 4 + 3] = 255; \
                v_idx++; \
            }

        #define ADD_QUAD_INDICES(IS_WATER) \
            /* Emit 6 vertices: 0, 1, 2, 0, 2, 3 */ \
            EMIT_VERTEX(0, IS_WATER); \
            EMIT_VERTEX(1, IS_WATER); \
            EMIT_VERTEX(2, IS_WATER); \
            EMIT_VERTEX(0, IS_WATER); \
            EMIT_VERTEX(2, IS_WATER); \
            EMIT_VERTEX(3, IS_WATER); \
            q_idx = 0;
        
        // Build mesh
        for (int x = 0; x < 16; x++) {
            for (int y = 0; y < CHUNK_HEIGHT; y++) {
                for (int z = 0; z < 16; z++) {
                    int btype = c->blocks[x][y][z];
                    if (btype == BLOCK_AIR) continue;
                    
                    int current_flag = 0;
                    if (btype == BLOCK_WATER) current_flag = 255;
                    else if (btype == BLOCK_LEAVES) current_flag = 100;
                    
                    #define SHOULD_RENDER_FACE(neighbor_block) \
                        ((btype == BLOCK_WATER) ? \
                            ((neighbor_block) == BLOCK_AIR || ((neighbor_block) >= 10 && (neighbor_block) <= 14) || (neighbor_block) == BLOCK_TALLGRASS || (neighbor_block) == BLOCK_LEAVES) : \
                            (IS_TRANSPARENT_MESH(neighbor_block)))
                    
                    int b_gx = gx_base + x;
                    int b_gz = gz_base + z;
                    
                    float px = (float)x;
                    float py = (float)y;
                    float pz = (float)z;
                    
                    float u_min, v_min, u_max, v_max;
                    
                    #define SET_UV(c, r) \
                        u_min = (float)(c) * 0.25f; \
                        v_min = (float)(r) * 0.333333f; \
                        u_max = u_min + 0.25f; \
                        v_max = v_min + 0.333333f;

                    #define CALC_LIGHT(gx, gy, gz, v) (v) = get_light_levels(chunks, num_chunks, (gx), (gy), (gz))

                    // --- TORCH HANDLING ---
                    if (btype >= 10 && btype <= 14) {
                         float tu_min = 0.75; float tv_min = 0.5; float tu_max = 1.0; float tv_max = 1.0;
                         int t_light = 255; 
                         float tw_x = 0.125; float tw_z = 0.125; float th = 0.5;
                         float bx = px + 0.5 - tw_x/2.0; float by = py; float bz = pz + 0.5 - tw_z/2.0;
                         float angle_offset = 0.3;
                         
                         if (btype == 11) { bz += 0.45; by += 0.1; }
                         else if (btype == 12) { bz -= 0.45; by += 0.1; }
                         else if (btype == 13) { bx += 0.45; by += 0.1; }
                         else if (btype == 14) { bx -= 0.45; by += 0.1; }
                         
                         float top_offset_x = 0.0; float top_offset_z = 0.0;
                         if (btype == 11) { top_offset_z = -angle_offset; }
                         else if (btype == 12) { top_offset_z = angle_offset; }
                         else if (btype == 13) { top_offset_x = -angle_offset; }
                         else if (btype == 14) { top_offset_x = angle_offset; }
                         
                         float top_bx = bx + top_offset_x;
                         float top_bz = bz + top_offset_z;
                         
                         ADD_VERTEX_GENERIC(bx, by, bz+tw_z, 0,0,1, tu_min, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(bx+tw_x, by, bz+tw_z, 0,0,1, tu_max, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx+tw_x, by+th, top_bz+tw_z, 0,0,1, tu_max, tv_min, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx, by+th, top_bz+tw_z, 0,0,1, tu_min, tv_min, t_light, 0);
                         ADD_QUAD_INDICES(0);
                         
                         ADD_VERTEX_GENERIC(bx+tw_x, by, bz, 0,0,-1, tu_min, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(bx, by, bz, 0,0,-1, tu_max, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx, by+th, top_bz, 0,0,-1, tu_max, tv_min, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx+tw_x, by+th, top_bz, 0,0,-1, tu_min, tv_min, t_light, 0);
                         ADD_QUAD_INDICES(0);
                         
                         ADD_VERTEX_GENERIC(bx, by, bz, -1,0,0, tu_min, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(bx, by, bz+tw_z, -1,0,0, tu_max, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx, by+th, top_bz+tw_z, -1,0,0, tu_max, tv_min, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx, by+th, top_bz, -1,0,0, tu_min, tv_min, t_light, 0);
                         ADD_QUAD_INDICES(0);
                         
                         ADD_VERTEX_GENERIC(bx+tw_x, by, bz+tw_z, 1,0,0, tu_min, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(bx+tw_x, by, bz, 1,0,0, tu_max, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx+tw_x, by+th, top_bz, 1,0,0, tu_max, tv_min, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx+tw_x, by+th, top_bz+tw_z, 1,0,0, tu_min, tv_min, t_light, 0);
                         ADD_QUAD_INDICES(0);
                         
                         ADD_VERTEX_GENERIC(top_bx, by+th, top_bz, 0,1,0, tu_min, tv_min, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx, by+th, top_bz+tw_z, 0,1,0, tu_min, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx+tw_x, by+th, top_bz+tw_z, 0,1,0, tu_max, tv_max, t_light, 0);
                         ADD_VERTEX_GENERIC(top_bx+tw_x, by+th, top_bz, 0,1,0, tu_max, tv_min, t_light, 0);
                         ADD_QUAD_INDICES(0);

                         continue;
                    }
                    
                    // WATER SPECIAL CASE
                    if (btype == BLOCK_WATER) {
                        int neighbor_above = get_block(chunks, num_chunks, b_gx, y + 1, b_gz);
                        if (neighbor_above != BLOCK_WATER && IS_TRANSPARENT_MESH(neighbor_above)) {
                            int light_val; CALC_LIGHT(b_gx, y + 1, b_gz, light_val);
                            
                            SET_UV(0, 0); 
                            float water_h = 0.75;
                            
                            ADD_VERTEX_GENERIC(px, py+water_h, pz,     0,1,0, u_min, v_min, light_val, 1);
                            ADD_VERTEX_GENERIC(px+1, py+water_h, pz,   0,1,0, u_max, v_min, light_val, 1);
                            ADD_VERTEX_GENERIC(px+1, py+water_h, pz+1, 0,1,0, u_max, v_max, light_val, 1);
                            ADD_VERTEX_GENERIC(px, py+water_h, pz+1,   0,1,0, u_min, v_max, light_val, 1);
                            ADD_QUAD_INDICES(1);
                        }
                        continue; 
                    }

                    // Normal Block Rendering
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx, y + 1, b_gz))) {
                        int light_val; CALC_LIGHT(b_gx, y + 1, b_gz, light_val);
                        if (btype == BLOCK_GRASS) { SET_UV(1, 0); } else if (btype == BLOCK_DIRT) { SET_UV(0, 0); } else if (btype == BLOCK_STONE) { SET_UV(1, 1); } else if (btype == BLOCK_LOG) { SET_UV(3, 0); } else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); } else if (btype == BLOCK_SAND) { SET_UV(0, 2); } else { SET_UV(0, 0); }

                        ADD_VERTEX_GENERIC(px, py+1, pz,     0,1,0, u_min, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py+1, pz,   0,1,0, u_max, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py+1, pz+1, 0,1,0, u_max, v_max, light_val, 0);
                        ADD_VERTEX_GENERIC(px, py+1, pz+1,   0,1,0, u_min, v_max, light_val, 0);
                        ADD_QUAD_INDICES(0);
                    }
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx, y - 1, b_gz))) {
                         int light_val; CALC_LIGHT(b_gx, y - 1, b_gz, light_val);
                        if (btype == BLOCK_GRASS) { SET_UV(0, 0); } else if (btype == BLOCK_DIRT) { SET_UV(0, 0); } else if (btype == BLOCK_STONE) { SET_UV(1, 1); } else if (btype == BLOCK_LOG) { SET_UV(3, 0); } else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); } else if (btype == BLOCK_SAND) { SET_UV(0, 2); } else { SET_UV(0, 0); }

                        ADD_VERTEX_GENERIC(px, py, pz,     0,-1,0, u_min, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py, pz,   0,-1,0, u_max, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py, pz+1, 0,-1,0, u_max, v_max, light_val, 0);
                        ADD_VERTEX_GENERIC(px, py, pz+1,   0,-1,0, u_min, v_max, light_val, 0);
                        ADD_QUAD_INDICES(0);
                    }
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx + 1, y, b_gz))) {
                         int light_val; CALC_LIGHT(b_gx + 1, y, b_gz, light_val);
                        if (btype == BLOCK_GRASS) { SET_UV(0, 1); } else if (btype == BLOCK_DIRT) { SET_UV(0, 0); } else if (btype == BLOCK_STONE) { SET_UV(1, 1); } else if (btype == BLOCK_LOG) { SET_UV(2, 0); } else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); } else if (btype == BLOCK_SAND) { SET_UV(0, 2); } else { SET_UV(0, 0); }

                        ADD_VERTEX_GENERIC(px+1, py, pz,     1,0,0, u_min, v_max, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py+1, pz,   1,0,0, u_min, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py+1, pz+1, 1,0,0, u_max, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py, pz+1,   1,0,0, u_max, v_max, light_val, 0);
                        ADD_QUAD_INDICES(0);
                    }
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx - 1, y, b_gz))) {
                         int light_val; CALC_LIGHT(b_gx - 1, y, b_gz, light_val);
                        if (btype == BLOCK_GRASS) { SET_UV(0, 1); } else if (btype == BLOCK_DIRT) { SET_UV(0, 0); } else if (btype == BLOCK_STONE) { SET_UV(1, 1); } else if (btype == BLOCK_LOG) { SET_UV(2, 0); } else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); } else if (btype == BLOCK_SAND) { SET_UV(0, 2); } else { SET_UV(0, 0); }

                        ADD_VERTEX_GENERIC(px, py, pz,     -1,0,0, u_min, v_max, light_val, 0);
                        ADD_VERTEX_GENERIC(px, py+1, pz,   -1,0,0, u_min, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px, py+1, pz+1, -1,0,0, u_max, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px, py, pz+1,   -1,0,0, u_max, v_max, light_val, 0);
                        ADD_QUAD_INDICES(0);
                    }
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx, y, b_gz + 1))) {
                         int light_val; CALC_LIGHT(b_gx, y, b_gz + 1, light_val);
                        if (btype == BLOCK_GRASS) { SET_UV(0, 1); } else if (btype == BLOCK_DIRT) { SET_UV(0, 0); } else if (btype == BLOCK_STONE) { SET_UV(1, 1); } else if (btype == BLOCK_LOG) { SET_UV(2, 0); } else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); } else if (btype == BLOCK_SAND) { SET_UV(0, 2); } else { SET_UV(0, 0); }

                        ADD_VERTEX_GENERIC(px, py, pz+1,     0,0,1, u_min, v_max, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py, pz+1,   0,0,1, u_max, v_max, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py+1, pz+1, 0,0,1, u_max, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px, py+1, pz+1,   0,0,1, u_min, v_min, light_val, 0);
                        ADD_QUAD_INDICES(0);
                    }
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx, y, b_gz - 1))) {
                         int light_val; CALC_LIGHT(b_gx, y, b_gz - 1, light_val);
                        if (btype == BLOCK_GRASS) { SET_UV(0, 1); } else if (btype == BLOCK_DIRT) { SET_UV(0, 0); } else if (btype == BLOCK_STONE) { SET_UV(1, 1); } else if (btype == BLOCK_LOG) { SET_UV(2, 0); } else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); } else if (btype == BLOCK_SAND) { SET_UV(0, 2); } else { SET_UV(0, 0); }

                        ADD_VERTEX_GENERIC(px, py, pz,     0,0,-1, u_min, v_max, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py, pz,   0,0,-1, u_max, v_max, light_val, 0);
                        ADD_VERTEX_GENERIC(px+1, py+1, pz, 0,0,-1, u_max, v_min, light_val, 0);
                        ADD_VERTEX_GENERIC(px, py+1, pz,   0,0,-1, u_min, v_min, light_val, 0);
                        ADD_QUAD_INDICES(0);
                    }
                    
                    #undef CALC_LIGHT
                    #undef SET_UV
                }
            }
        }
        
        #undef ADD_VERTEX_GENERIC
        #undef ADD_QUAD_INDICES
        #undef SHOULD_RENDER_FACE

        // Create Opaque Mesh Data
        if (v_idx > 0) {
            res.opq_mesh.vertexCount = v_idx;
            res.opq_mesh.triangleCount = v_idx / 3;
            res.opq_mesh.vertices = vertices;
            res.opq_mesh.texcoords = texcoords;
            res.opq_mesh.normals = normals;
            res.opq_mesh.colors = colors;
            res.opq_mesh.indices = NULL;
            res.has_opaque = 1;
        } else {
            if (vertices != NULL) { free(vertices); free(texcoords); free(normals); free(colors); }
            res.has_opaque = 0;
        }

        // Create Transparent Mesh Data
        if (w_v_idx > 0) {
            res.water.vertexCount = w_v_idx;
            res.water.triangleCount = w_v_idx / 3;
            res.water.vertices = w_vertices;
            res.water.texcoords = w_texcoords;
            res.water.normals = w_normals;
            res.water.colors = w_colors;
            res.water.indices = NULL;
            res.has_water = 1;
        } else {
             if (w_vertices != NULL) { free(w_vertices); free(w_texcoords); free(w_normals); free(w_colors); }
             res.has_water = 0;
        }
        
        return res;
    }
}

fn compute_plant_mesh(c: Chunk*) -> rl::Mesh {
    let mesh: rl::Mesh;
    raw {
        memset(&mesh, 0, sizeof(Mesh));
        if (c->plant_count == 0) {
            return mesh; // Empty (vertexCount = 0)
        }

        
        int vertex_count = c->plant_count * 12;
        
        float* vertices = (float*)malloc(vertex_count * 3 * sizeof(float));
        float* normals = (float*)malloc(vertex_count * 3 * sizeof(float));
        float* texcoords = (float*)malloc(vertex_count * 2 * sizeof(float));
        unsigned char* colors = (unsigned char*)malloc(vertex_count * 4 * sizeof(unsigned char));
        
        int v_idx = 0;
        
        #define ADD_VERTEX_P(px, py, pz, nx, ny, nz, u, v, light_val, flag) \
            vertices[v_idx * 3 + 0] = (float)(px); \
            vertices[v_idx * 3 + 1] = (float)(py); \
            vertices[v_idx * 3 + 2] = (float)(pz); \
            normals[v_idx * 3 + 0] = (nx); \
            normals[v_idx * 3 + 1] = (ny); \
            normals[v_idx * 3 + 2] = (nz); \
            texcoords[v_idx * 2 + 0] = (u); \
            texcoords[v_idx * 2 + 1] = (v); \
            colors[v_idx * 4 + 0] = (((light_val >> 4) & 0xF) * 17);  \
            colors[v_idx * 4 + 1] = ((light_val & 0xF) * 17);         \
            colors[v_idx * 4 + 2] = flag; \
            colors[v_idx * 4 + 3] = 255; \
            v_idx++;

        for (int i = 0; i < c->plant_count; i++) {
            float size = 0.8f;
            float offset = (1.0f - size) / 2.0f;
            
            float cx = c->plants[i].x;
            float cy = c->plants[i].y;
            float cz = c->plants[i].z;
            
            float x0 = cx - size/2.0f;
            float x1 = cx + size/2.0f;
            float y0 = cy;
            float y1 = cy + size; 
            float z0 = cz - size/2.0f;
            float z1 = cz + size/2.0f;
            
            int lx = (int)cx;
            int ly = (int)cy;
            int lz = (int)cz;
            int light_val = 0x0F; 
            
            if (lx>=0 && lx<16 && ly>=0 && ly<32 && lz>=0 && lz<16) {
                light_val = c->light[lx][ly][lz]; 
            }
            
            float u_min = 0.0f; float v_min = 0.0f; float u_max = 1.0f; float v_max = 1.0f;
            
            // Plane 1
            ADD_VERTEX_P(x0, y0, z0,  0,0,1, u_min, v_max, light_val, 0);
            ADD_VERTEX_P(x1, y0, z1,  0,0,1, u_max, v_max, light_val, 0);
            ADD_VERTEX_P(x1, y1, z1,  0,0,1, u_max, v_min, light_val, 100);
            
            ADD_VERTEX_P(x0, y0, z0,  0,0,1, u_min, v_max, light_val, 0);
            ADD_VERTEX_P(x1, y1, z1,  0,0,1, u_max, v_min, light_val, 100);
            ADD_VERTEX_P(x0, y1, z0,  0,0,1, u_min, v_min, light_val, 100);
            
            // Plane 2
            ADD_VERTEX_P(x1, y0, z0,  0,0,1, u_min, v_max, light_val, 0);
            ADD_VERTEX_P(x0, y0, z1,  0,0,1, u_max, v_max, light_val, 0);
            ADD_VERTEX_P(x0, y1, z1,  0,0,1, u_max, v_min, light_val, 100);
            
            ADD_VERTEX_P(x1, y0, z0,  0,0,1, u_min, v_max, light_val, 0);
            ADD_VERTEX_P(x0, y1, z1,  0,0,1, u_max, v_min, light_val, 100);
            ADD_VERTEX_P(x1, y1, z0,  0,0,1, u_min, v_min, light_val, 100);
        }
        
        #undef ADD_VERTEX_P
        
        mesh.vertexCount = vertex_count;
        mesh.triangleCount = vertex_count / 3;
        mesh.vertices = vertices;
        mesh.normals = normals;
        mesh.texcoords = texcoords;
        return mesh;
    }
}

// --- Upload Functions (Main Thread - GPU) ---

fn upload_chunk_mesh(c: Chunk*, meshes: ChunkMeshes) {
    if c == NULL { return; }

    // Unload existing models properly
    if c.mesh_built == 1 {
        rl::SetTraceLogLevel(rl::LOG_WARNING);
        rl::UnloadModel(c.chunk_model);
        rl::SetTraceLogLevel(rl::LOG_WARNING); // Keep at warning
        c.mesh_built = 0;
    }
    if c.water_mesh_built == 1 {
        rl::SetTraceLogLevel(rl::LOG_WARNING);
        rl::UnloadModel(c.water_model);
        rl::SetTraceLogLevel(rl::LOG_WARNING);
        c.water_mesh_built = 0;
    }

    // Upload Opaque
    if meshes.has_opaque == 1 {
        // We have new valid mesh data on CPU (Mesh struct with pointers)
        // UploadMesh sends it to GPU (VAO/VBO)
        rl::SetTraceLogLevel(rl::LOG_WARNING);
        rl::UploadMesh(&meshes.opq_mesh, false);
        // rl::SetTraceLogLevel(rl::LOG_INFO); // Removed to reduce spam
        
        c.chunk_mesh = meshes.opq_mesh;
        c.chunk_model = rl::LoadModelFromMesh(meshes.opq_mesh);
        c.mesh_built = 1;
        
        c.chunk_model.materials[0].shader = get_shader_lighting();
        c.chunk_model.materials[0].maps[MATERIAL_MAP_DIFFUSE].texture = get_tex_atlas();
    } else {
        // Empty chunk or only water?
        // Create dummy cube to avoid render errors or just mark as built?
        // Marking as built is enough if we check mesh_built in draw.
        // But draw_opaque checks x != -9999.
        // Let's create dummy for safety as before.
        c.chunk_mesh = rl::GenMeshCube(0.0f, 0.0f, 0.0f);
        c.chunk_model = rl::LoadModelFromMesh(c.chunk_mesh);
        c.mesh_built = 1;
    }

    // Upload Water
    if meshes.has_water == 1 {
        rl::SetTraceLogLevel(rl::LOG_WARNING);
        rl::UploadMesh(&meshes.water, false);
        // rl::SetTraceLogLevel(rl::LOG_INFO); // Removed
        
        c.water_mesh = meshes.water;
        c.water_model = rl::LoadModelFromMesh(meshes.water);
        c.water_mesh_built = 1;
        
        c.water_model.materials[0].shader = get_shader_lighting();
        c.water_model.materials[0].maps[MATERIAL_MAP_DIFFUSE].texture = get_tex_atlas();
    } else {
        c.water_mesh = rl::GenMeshCube(0.0f, 0.0f, 0.0f);
        c.water_model = rl::LoadModelFromMesh(c.water_mesh);
        c.water_mesh_built = 0; // Don't draw dummy water
    }
    
    // Important: The Model struct now contains the Mesh which contains pointers to vertices.
    // Raylib UNLOADS these pointers when UnloadModel is called later.
    // So we do NOT free them here.
    
    c.mesh_dirty = 0;
}

fn upload_plant_mesh(c: Chunk*, mesh: rl::Mesh) {
    if c == NULL { return; }
    
    if c.plant_mesh_built == 1 {
        rl::SetTraceLogLevel(rl::LOG_WARNING);
        rl::UnloadModel(c.plant_model);
        c.plant_mesh_built = 0;
    }
    
    if mesh.vertexCount > 0 {
        rl::SetTraceLogLevel(rl::LOG_WARNING);
        rl::UploadMesh(&mesh, false);
        // rl::SetTraceLogLevel(rl::LOG_INFO); // Removed
        
        c.plant_mesh = mesh;
        c.plant_model = rl::LoadModelFromMesh(mesh);
        c.plant_mesh_built = 1;
        
        c.plant_model.materials[0].shader = get_shader_lighting();
        c.plant_model.materials[0].maps[MATERIAL_MAP_DIFFUSE].texture = get_tex_grass();
    } else {
         c.plant_mesh_built = 1; // Empty but "built"
    }
}

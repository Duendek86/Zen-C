//> This file contains the chunk mesh building implementation

import "raylib.h" as rl;
import "rlgl.h";
import "blocks.zc";
import "chunk.zc";
import "rendering.zc";

// No externs needed

fn build_chunk_mesh(c: Chunk*, chunks: Chunk*, num_chunks: int) {
    // Note: We don't unload the old mesh - we just overwrite it
    // This avoids crashes when the mesh is still being referenced
    
    let gx_base = c.x * 16;
    let gz_base = c.z * 16;
    
    raw {
        // Count visible faces first to allocate exact size
        int face_count = 0;
        
        for (int x = 0; x < 16; x++) {
            for (int y = 0; y < 32; y++) {
                for (int z = 0; z < 16; z++) {
                    int btype = c->blocks[x][y][z];
                    if (btype == BLOCK_AIR) continue;
                    
                    int b_gx = gx_base + x;
                    int b_gz = gz_base + z;

                    
                    // Check each face for solid blocks
                    if (btype >= 10 && btype <= 14) {
                        // Torches: Always count 6 faces (safe estimate)
                        face_count = face_count + 6;
                        continue;
                    }

                    // Check neighbors. Draw face if neighbor is AIR OR TORCH (Transparent)
                    // Helper macro or inline
                    
                    if (IS_TRANSPARENT(get_block(chunks, num_chunks, b_gx + 1, y, b_gz))) face_count++; // +X
                    if (IS_TRANSPARENT(get_block(chunks, num_chunks, b_gx - 1, y, b_gz))) face_count++; // -X
                    if (IS_TRANSPARENT(get_block(chunks, num_chunks, b_gx, y + 1, b_gz))) face_count++; // +Y
                    if (IS_TRANSPARENT(get_block(chunks, num_chunks, b_gx, y - 1, b_gz))) face_count++; // -Y
                    if (IS_TRANSPARENT(get_block(chunks, num_chunks, b_gx, y, b_gz + 1))) face_count++; // +Z
                    if (IS_TRANSPARENT(get_block(chunks, num_chunks, b_gx, y, b_gz - 1))) face_count++; // -Z
                }
            }
        }
        
        
        if (face_count == 0) {
            // Empty chunk, create dummy mesh
            c->chunk_mesh = GenMeshCube(0.0f, 0.0f, 0.0f);
            c->chunk_model = LoadModelFromMesh(c->chunk_mesh);
            c->mesh_built = 1;
            c->mesh_dirty = 0;
            return;
        }
        
        // Allocate vertex data (6 vertices per face = 2 triangles)
        int vertex_count = face_count * 6;
        float* vertices = (float*)malloc(vertex_count * 3 * sizeof(float));
        float* normals = (float*)malloc(vertex_count * 3 * sizeof(float));
        float* texcoords = (float*)malloc(vertex_count * 2 * sizeof(float));
        unsigned char* colors = (unsigned char*)malloc(vertex_count * 4 * sizeof(unsigned char));
        
        int v_idx = 0;
        
        // Helper macro to add vertex uses current_flag from scope
        // Colors: R = Block Light, G = Sky Light, B = Flag (0=None, 100=Wind, 255=Water)
        #define ADD_VERTEX(px, py, pz, nx, ny, nz, u, v, light_val) \
            vertices[v_idx * 3 + 0] = (float)(px); \
            vertices[v_idx * 3 + 1] = (float)(py); \
            vertices[v_idx * 3 + 2] = (float)(pz); \
            normals[v_idx * 3 + 0] = (nx); \
            normals[v_idx * 3 + 1] = (ny); \
            normals[v_idx * 3 + 2] = (nz); \
            texcoords[v_idx * 2 + 0] = (u); \
            texcoords[v_idx * 2 + 1] = (v); \
            colors[v_idx * 4 + 0] = ((light_val & 0xF) * 17);        /* Block Light (R) */ \
            colors[v_idx * 4 + 1] = (((light_val >> 4) & 0xF) * 17); /* Sky Light (G) */ \
            colors[v_idx * 4 + 2] = current_flag;                    /* Flag (B) */ \
            colors[v_idx * 4 + 3] = 255; \
            v_idx++;
        
        
        // Build mesh
        for (int x = 0; x < 16; x++) {
            for (int y = 0; y < 32; y++) {
                for (int z = 0; z < 16; z++) {
                    int btype = c->blocks[x][y][z];
                    if (btype == BLOCK_AIR) continue;
                    
                    int current_flag = 0;
                    if (btype == BLOCK_WATER) current_flag = 255;
                    else if (btype == BLOCK_LEAVES) current_flag = 100;
                    
                    // Helper: Should we render a face?
                    // For water blocks, don't render faces against other water blocks
                    // This makes water appear as one solid volume instead of a grid
                    #define SHOULD_RENDER_FACE(neighbor_block) \
                        (IS_TRANSPARENT(neighbor_block) && \
                         !(btype == BLOCK_WATER && (neighbor_block) == BLOCK_WATER))
                    
                    int b_gx = gx_base + x;
                    int b_gz = gz_base + z;
                    
                    float px = (float)x;
                    float py = (float)y;
                    float pz = (float)z;
                    
                    // Texture atlas UVs (4x2 grid: 0.25 wide, 0.5 high per texture)
                    // Layout:
                    // Row 0 (V=0.0-0.5): [Dirt][Grass_Top][Log_Side][Log_Top]
                    // Row 1 (V=0.5-1.0): [Grass_Side][Stone][Leaves][Empty]
                    
                    float u_min, v_min, u_max, v_max;
                    
                    // Helpers for Atlas coords (col, row)
                    // Col: 0..3, Row: 0..1
                    #define SET_UV(c, r) \
                        u_min = (float)(c) * 0.25f; \
                        v_min = (float)(r) * 0.5f; \
                        u_max = u_min + 0.25f; \
                        v_max = v_min + 0.5f;
                    
                    // Lighting Curve Calculation
                    // We want faster falloff. Linear * 16 is too bright.
                    // Use quadratic curve: (light / 15.0)^2 * 255
                    // Integer approximation: light * light
                    // 15*15 = 225. 255 max. 
                    // Let's use simple lookup or x*x approximation.
                    // light=15 -> 225 (close to 255)
                    // light=10 -> 100 (vs 160 linear)
                    // light=5 -> 25 (vs 80 linear)
                    // light=1 -> 1 (vs 16 linear) -> Pitch black practically.
                    
                    // Simple macro for curve
                    #define CALC_LIGHT(l) ((unsigned char)((l) * (l)))
                    
                    // --- TORCH HANDLING ---
                    // Torches are special. They are not cubes.
                    // Variants: 10=Up, 11=N, 12=S, 13=E, 14=W
                    if (btype >= 10 && btype <= 14) {
                         // Torch Atlas pos is (3,1)
                         // 4 cols x 2 rows. 
                         // u=3*0.25=0.75, v=1*0.5=0.5
                         float tu_min = 0.75;
                         float tv_min = 0.5;
                         float tu_max = 1.0;
                         float tv_max = 1.0;
                         
                         int t_light = 255; // Maximum brightness for emissive look
                         
                         // Stick geometry: Thin torch like Minecraft
                         // 2 pixels wide, 1/2 block tall
                         float tw_x = 0.125;   // Width in X (2 pixels)
                         float tw_z = 0.125;   // Depth in Z (2 pixels) 
                         float th = 0.5;       // Height (8 pixels)
                         
                         // Base position - center the torch
                         float bx = px + 0.5 - tw_x/2.0; 
                         float by = py;
                         float bz = pz + 0.5 - tw_z/2.0;
                         
                         // Apply offsets and angles for wall torches
                         // Wall torches are angled 45 degrees away from wall
                         float angle_offset = 0.3; // How far torch leans out
                         
                         if (btype == 11) { // North wall (Z+)
                             bz += 0.45; // Move closer to wall
                             by += 0.1;  // Slight lift
                             // Angle: top goes toward -Z
                         }
                         else if (btype == 12) { // South wall (Z-)
                             bz -= 0.45;
                             by += 0.1;
                         }
                         else if (btype == 13) { // East wall (X+)
                             bx += 0.45;
                             by += 0.1;
                         }
                         else if (btype == 14) { // West wall (X-)
                             bx -= 0.45;
                             by += 0.1;
                         }
                         
                         // Draw Box (Stick) - CCW winding order for correct face visibility
                         // For wall torches, angle the top vertices
                         
                         // Calculate top offset for angling (only for wall torches)
                         float top_offset_x = 0.0;
                         float top_offset_z = 0.0;
                         
                         if (btype == 11) { top_offset_z = -angle_offset; } // North: lean away (toward -Z)
                         else if (btype == 12) { top_offset_z = angle_offset; } // South: lean away (toward +Z)
                         else if (btype == 13) { top_offset_x = -angle_offset; } // East: lean away (toward -X)
                         else if (btype == 14) { top_offset_x = angle_offset; } // West: lean away (toward +X)
                         
                         // Top vertices are at (bx+offset, by+th, bz+offset) instead of (bx, by+th, bz)
                         float top_bx = bx + top_offset_x;
                         float top_bz = bz + top_offset_z;
                         
                         // Front (+Z) - CCW when looking at -Z
                         ADD_VERTEX(bx, by, bz+tw_z, 0,0,1, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz+tw_z, 0,0,1, tu_max, tv_min, t_light);
                         ADD_VERTEX(bx+tw_x, by, bz+tw_z, 0,0,1, tu_max, tv_max, t_light);
                         ADD_VERTEX(bx, by, bz+tw_z, 0,0,1, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx, by+th, top_bz+tw_z, 0,0,1, tu_min, tv_min, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz+tw_z, 0,0,1, tu_max, tv_min, t_light);
                         
                         // Back (-Z) - CCW when looking at +Z
                         ADD_VERTEX(bx+tw_x, by, bz, 0,0,-1, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx, by+th, top_bz, 0,0,-1, tu_max, tv_min, t_light);
                         ADD_VERTEX(bx, by, bz, 0,0,-1, tu_max, tv_max, t_light);
                         ADD_VERTEX(bx+tw_x, by, bz, 0,0,-1, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz, 0,0,-1, tu_min, tv_min, t_light);
                         ADD_VERTEX(top_bx, by+th, top_bz, 0,0,-1, tu_max, tv_min, t_light);
                         
                         // Left (-X) - CCW when looking at +X
                         ADD_VERTEX(bx, by, bz, -1,0,0, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx, by+th, top_bz+tw_z, -1,0,0, tu_max, tv_min, t_light);
                         ADD_VERTEX(bx, by, bz+tw_z, -1,0,0, tu_max, tv_max, t_light);
                         ADD_VERTEX(bx, by, bz, -1,0,0, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx, by+th, top_bz, -1,0,0, tu_min, tv_min, t_light);
                         ADD_VERTEX(top_bx, by+th, top_bz+tw_z, -1,0,0, tu_max, tv_min, t_light);
                         
                         // Right (+X) - CCW when looking at -X
                         ADD_VERTEX(bx+tw_x, by, bz+tw_z, 1,0,0, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz, 1,0,0, tu_max, tv_min, t_light);
                         ADD_VERTEX(bx+tw_x, by, bz, 1,0,0, tu_max, tv_max, t_light);
                         ADD_VERTEX(bx+tw_x, by, bz+tw_z, 1,0,0, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz+tw_z, 1,0,0, tu_min, tv_min, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz, 1,0,0, tu_max, tv_min, t_light);
                         
                         // Top (+Y) - CCW when looking down
                         ADD_VERTEX(top_bx, by+th, top_bz, 0,1,0, tu_min, tv_min, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz+tw_z, 0,1,0, tu_max, tv_max, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz, 0,1,0, tu_max, tv_min, t_light);
                         ADD_VERTEX(top_bx, by+th, top_bz, 0,1,0, tu_min, tv_min, t_light);
                         ADD_VERTEX(top_bx, by+th, top_bz+tw_z, 0,1,0, tu_min, tv_max, t_light);
                         ADD_VERTEX(top_bx+tw_x, by+th, top_bz+tw_z, 0,1,0, tu_max, tv_max, t_light);

                         continue; // Skip standard cube logic
                    }
                    
                    // WATER SPECIAL CASE: Only render top surface
                    if (btype == BLOCK_WATER) {
                        // Only draw +Y face (top) if exposed
                        int neighbor_above = get_block(chunks, num_chunks, b_gx, y + 1, b_gz);
                        if (neighbor_above != BLOCK_WATER && IS_TRANSPARENT(neighbor_above)) {
                            int l_sky = get_light_global(chunks, num_chunks, b_gx, y + 1, b_gz, 0);
                            int l_blk = get_light_global(chunks, num_chunks, b_gx, y + 1, b_gz, 1);
                            int light_val = (l_blk << 4) | l_sky;
                            
                            SET_UV(0, 0); // Water uses dirt texture (will be overridden by shader)
                            
                            ADD_VERTEX(px, py+1, pz,     0,1,0, u_min, v_min, light_val);
                            ADD_VERTEX(px+1, py+1, pz,   0,1,0, u_max, v_min, light_val);
                            ADD_VERTEX(px+1, py+1, pz+1, 0,1,0, u_max, v_max, light_val);
                            
                            ADD_VERTEX(px, py+1, pz,     0,1,0, u_min, v_min, light_val);
                            ADD_VERTEX(px+1, py+1, pz+1, 0,1,0, u_max, v_max, light_val);
                            ADD_VERTEX(px, py+1, pz+1,   0,1,0, u_min, v_max, light_val);
                        }
                        continue; // Skip all other faces for water
                    }

                    // +Y face (top)
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx, y + 1, b_gz))) {
                        int l_sky = get_light_global(chunks, num_chunks, b_gx, y + 1, b_gz, 0);
                        int l_blk = get_light_global(chunks, num_chunks, b_gx, y + 1, b_gz, 1);
                        int light_val = (l_blk << 4) | l_sky;

                        if (btype == BLOCK_GRASS) { SET_UV(1, 0); }      // Grass Top
                        else if (btype == BLOCK_DIRT) { SET_UV(0, 0); }  // Dirt
                        else if (btype == BLOCK_STONE) { SET_UV(1, 1); } // Stone
                        else if (btype == BLOCK_LOG) { SET_UV(3, 0); }   // Log Top
                        else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); }// Leaves
                        else { SET_UV(0, 0); }

                        ADD_VERTEX(px, py+1, pz,     0,1,0, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz,   0,1,0, u_max, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 0,1,0, u_max, v_max, light_val);
                        
                        ADD_VERTEX(px, py+1, pz,     0,1,0, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 0,1,0, u_max, v_max, light_val);
                        ADD_VERTEX(px, py+1, pz+1,   0,1,0, u_min, v_max, light_val);
                    }
                    
                    // -Y face (bottom)
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx, y - 1, b_gz))) {
                        int l_sky = get_light_global(chunks, num_chunks, b_gx, y - 1, b_gz, 0);
                        int l_blk = get_light_global(chunks, num_chunks, b_gx, y - 1, b_gz, 1);
                        int light_val = (l_blk << 4) | l_sky;

                        if (btype == BLOCK_GRASS) { SET_UV(0, 0); }      // Dirt
                        else if (btype == BLOCK_DIRT) { SET_UV(0, 0); }  // Dirt
                        else if (btype == BLOCK_STONE) { SET_UV(1, 1); } // Stone
                        else if (btype == BLOCK_LOG) { SET_UV(3, 0); }   // Log Top
                        else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); }// Leaves
                        else { SET_UV(0, 0); }

                        ADD_VERTEX(px, py, pz,     0,-1,0, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py, pz,   0,-1,0, u_max, v_min, light_val);
                        ADD_VERTEX(px+1, py, pz+1, 0,-1,0, u_max, v_max, light_val);
                        
                        ADD_VERTEX(px, py, pz,     0,-1,0, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py, pz+1, 0,-1,0, u_max, v_max, light_val);
                        ADD_VERTEX(px, py, pz+1,   0,-1,0, u_min, v_max, light_val);
                    }
                    
                    // +X face (right)
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx + 1, y, b_gz))) {
                        int l_sky = get_light_global(chunks, num_chunks, b_gx + 1, y, b_gz, 0);
                        int l_blk = get_light_global(chunks, num_chunks, b_gx + 1, y, b_gz, 1);
                        int light_val = (l_blk << 4) | l_sky;

                        if (btype == BLOCK_GRASS) { SET_UV(0, 1); }      // Grass Side
                        else if (btype == BLOCK_DIRT) { SET_UV(0, 0); }  // Dirt
                        else if (btype == BLOCK_STONE) { SET_UV(1, 1); } // Stone
                        else if (btype == BLOCK_LOG) { SET_UV(2, 0); }   // Log Side
                        else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); }// Leaves
                        else { SET_UV(0, 0); }

                        ADD_VERTEX(px+1, py, pz,     1,0,0, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py, pz+1,   1,0,0, u_max, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 1,0,0, u_max, v_min, light_val);
                        
                        ADD_VERTEX(px+1, py, pz,     1,0,0, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 1,0,0, u_max, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz,   1,0,0, u_min, v_min, light_val);
                    }
                    
                    // -X face (left)
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx - 1, y, b_gz))) {
                        int l_sky = get_light_global(chunks, num_chunks, b_gx - 1, y, b_gz, 0);
                        int l_blk = get_light_global(chunks, num_chunks, b_gx - 1, y, b_gz, 1);
                        int light_val = (l_blk << 4) | l_sky;

                        if (btype == BLOCK_GRASS) { SET_UV(0, 1); }      // Grass Side
                        else if (btype == BLOCK_DIRT) { SET_UV(0, 0); }  // Dirt
                        else if (btype == BLOCK_STONE) { SET_UV(1, 1); } // Stone
                        else if (btype == BLOCK_LOG) { SET_UV(2, 0); }   // Log Side
                        else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); }// Leaves
                        else { SET_UV(0, 0); }

                        ADD_VERTEX(px, py, pz,     -1,0,0, u_min, v_max, light_val);
                        ADD_VERTEX(px, py+1, pz,   -1,0,0, u_min, v_min, light_val);
                        ADD_VERTEX(px, py+1, pz+1, -1,0,0, u_max, v_min, light_val);
                        
                        ADD_VERTEX(px, py, pz,     -1,0,0, u_min, v_max, light_val);
                        ADD_VERTEX(px, py+1, pz+1, -1,0,0, u_max, v_min, light_val);
                        ADD_VERTEX(px, py, pz+1,   -1,0,0, u_max, v_max, light_val);
                    }
                    
                    // +Z face (front)
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx, y, b_gz + 1))) {
                        int l_sky = get_light_global(chunks, num_chunks, b_gx, y, b_gz + 1, 0);
                        int l_blk = get_light_global(chunks, num_chunks, b_gx, y, b_gz + 1, 1);
                        int light_val = (l_blk << 4) | l_sky;

                        if (btype == BLOCK_GRASS) { SET_UV(0, 1); }      // Grass Side
                        else if (btype == BLOCK_DIRT) { SET_UV(0, 0); }  // Dirt
                        else if (btype == BLOCK_STONE) { SET_UV(1, 1); } // Stone
                        else if (btype == BLOCK_LOG) { SET_UV(2, 0); }   // Log Side
                        else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); }// Leaves
                        else { SET_UV(0, 0); }

                        ADD_VERTEX(px, py, pz+1,     0,0,1, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py, pz+1,   0,0,1, u_max, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 0,0,1, u_max, v_min, light_val);
                        
                        ADD_VERTEX(px, py, pz+1,     0,0,1, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz+1, 0,0,1, u_max, v_min, light_val);
                        ADD_VERTEX(px, py+1, pz+1,   0,0,1, u_min, v_min, light_val);
                    }
                    
                    // -Z face (back)
                    if (SHOULD_RENDER_FACE(get_block(chunks, num_chunks, b_gx, y, b_gz - 1))) {
                        int l_sky = get_light_global(chunks, num_chunks, b_gx, y, b_gz - 1, 0);
                        int l_blk = get_light_global(chunks, num_chunks, b_gx, y, b_gz - 1, 1);
                        int light_val = (l_blk << 4) | l_sky;

                        if (btype == BLOCK_GRASS) { SET_UV(0, 1); }      // Grass Side
                        else if (btype == BLOCK_DIRT) { SET_UV(0, 0); }  // Dirt
                        else if (btype == BLOCK_STONE) { SET_UV(1, 1); } // Stone
                        else if (btype == BLOCK_LOG) { SET_UV(2, 0); }   // Log Side
                        else if (btype == BLOCK_LEAVES) { SET_UV(2, 1); }// Leaves
                        else { SET_UV(0, 0); }

                        ADD_VERTEX(px, py, pz,     0,0,-1, u_min, v_max, light_val);
                        ADD_VERTEX(px, py+1, pz,   0,0,-1, u_min, v_min, light_val);
                        ADD_VERTEX(px+1, py+1, pz, 0,0,-1, u_max, v_min, light_val);
                        
                        ADD_VERTEX(px, py, pz,     0,0,-1, u_min, v_max, light_val);
                        ADD_VERTEX(px+1, py+1, pz, 0,0,-1, u_max, v_min, light_val);
                        ADD_VERTEX(px+1, py, pz,   0,0,-1, u_max, v_max, light_val);
                    }
                    
                    #undef CALC_LIGHT
                    #undef SET_UV
                }
            }
        }

        #undef ADD_VERTEX
        
        // Create mesh
        Mesh mesh = { 0 };
        mesh.vertexCount = vertex_count;
        mesh.triangleCount = vertex_count / 3;
        mesh.vertices = vertices;
        mesh.normals = normals;
        mesh.texcoords = texcoords;
        mesh.colors = colors;
        
        // Upload to GPU
        // Silence "Mesh uploaded successfully" INFO log
        SetTraceLogLevel(LOG_WARNING);
        UploadMesh(&mesh, false);
        SetTraceLogLevel(LOG_INFO);
        
        c->chunk_mesh = mesh;
        c->chunk_model = LoadModelFromMesh(mesh);
        
        // Assign shader and texture
        c->chunk_model.materials[0].shader = get_shader_lighting();
        c->chunk_model.materials[0].maps[MATERIAL_MAP_DIFFUSE].texture = get_tex_atlas();
        
        c->mesh_built = 1;
        c->mesh_dirty = 0;
    }
}

fn build_plant_mesh(c: Chunk*, plant_tex: rl::Texture2D) {
    // Note: We overwrite old mesh
    
    raw {
        if (c->plant_count == 0) {
            c->plant_mesh_built = 1;
            return;
        }
        
        // 4 vertices per plant * 2 (Wait, X shape = 2 quads = 4 triangles = 12 vertices? Or 4 vertices with indices? 
        // We use ADD_VERTEX which adds 3 vertices per triangle.
        // X shape = 2 planes. each plane = 2 triangles = 6 vertices.
        // Total 12 vertices per plant.
        int vertex_count = c->plant_count * 12;
        
        // Ensure at least ... logic not needed if we abort on count=0 earlier, but let's be safe for malloc
        if (vertex_count == 0) return; // Should be caught by early check

        
        // Allocate ...
        // Reuse macro? Need to define it again or make it available.
        // It was #defined inside build_chunk_mesh. We need to copy-paste or move it.
        // Let's redefine it here to be safe and simple.
        
        float* vertices = (float*)malloc(vertex_count * 3 * sizeof(float));
        float* normals = (float*)malloc(vertex_count * 3 * sizeof(float));
        float* texcoords = (float*)malloc(vertex_count * 2 * sizeof(float));
        unsigned char* colors = (unsigned char*)malloc(vertex_count * 4 * sizeof(unsigned char));
        
        int v_idx = 0;
        
        #define ADD_VERTEX_P(px, py, pz, nx, ny, nz, u, v, light_val, flag) \
            vertices[v_idx * 3 + 0] = (float)(px); \
            vertices[v_idx * 3 + 1] = (float)(py); \
            vertices[v_idx * 3 + 2] = (float)(pz); \
            normals[v_idx * 3 + 0] = (nx); \
            normals[v_idx * 3 + 1] = (ny); \
            normals[v_idx * 3 + 2] = (nz); \
            texcoords[v_idx * 2 + 0] = (u); \
            texcoords[v_idx * 2 + 1] = (v); \
            colors[v_idx * 4 + 0] = (((light_val >> 4) & 0xF) * 17); /* Block Light (R) */ \
            colors[v_idx * 4 + 1] = ((light_val & 0xF) * 17);        /* Sky Light (G) */ \
            colors[v_idx * 4 + 2] = flag; \
            colors[v_idx * 4 + 3] = 255; \
            v_idx++;

        for (int i = 0; i < c->plant_count; i++) {
            // Half size: 0.5 width/height relative to block?
            // Block is 1.0x1.0.
            // "ocupe la mitad de un bloque" -> 0.5 height, 0.5 width.
            // Center the plant.
            // Block center is x.5, z.5.
            // If plant is 0.5 wide, it goes from 0.25 to 0.75 relative to block corner.
            // And height 0.5.
            
            float size = 0.8f;
            float offset = (1.0f - size) / 2.0f;
            
            // Plants entities store relative coords inside chunk (e.g. 5.5, 6.0, 3.5)?
            // In Chunk::new: x = cx + 0.5f.
            // So x is centered.
            // For block rendering, we used corner coords.
            // Let's assume plant.x/y/z dictates the *bottom center* of the plant.
            
            float cx = c->plants[i].x;
            float cy = c->plants[i].y;
            float cz = c->plants[i].z;
            
            // Vertices from (cx - size/2) to (cx + size/2)
            float x0 = cx - size/2.0f;
            float x1 = cx + size/2.0f;
            float y0 = cy;
            float y1 = cy + size; // 0.5 unit high
            float z0 = cz - size/2.0f;
            float z1 = cz + size/2.0f;
            
            // Light
            int lx = (int)cx;
            int ly = (int)cy;
            int lz = (int)cz;
            int light_val = 0x0F; // Default to Skylight 15, Blocklight 0
            
            // Bounds check
            if (lx>=0 && lx<16 && ly>=0 && ly<32 && lz>=0 && lz<16) {
                // Get packed light value directly
                light_val = c->light[lx][ly][lz]; 
            }
            
            // No need to multiply by 16 or cast to char. 
            // ADD_VERTEX_P expects the packed int (0xBS) and does the decoding/scaling.
            
            // UVs: full sprite (0..1)
            float u_min = 0.0f; float v_min = 0.0f; float u_max = 1.0f; float v_max = 1.0f;
            
            // Plane 1: (x0, z0) to (x1, z1)
            // Bottom vertices (y0) -> flag 0
            // Top vertices (y1) -> flag 100
            
            ADD_VERTEX_P(x0, y0, z0,  0,0,1, u_min, v_max, light_val, 0);
            ADD_VERTEX_P(x1, y0, z1,  0,0,1, u_max, v_max, light_val, 0);
            ADD_VERTEX_P(x1, y1, z1,  0,0,1, u_max, v_min, light_val, 100);
            
            ADD_VERTEX_P(x0, y0, z0,  0,0,1, u_min, v_max, light_val, 0);
            ADD_VERTEX_P(x1, y1, z1,  0,0,1, u_max, v_min, light_val, 100);
            ADD_VERTEX_P(x0, y1, z0,  0,0,1, u_min, v_min, light_val, 100);
            
            // Plane 2: (x1, z0) to (x0, z1)
            ADD_VERTEX_P(x1, y0, z0,  0,0,1, u_min, v_max, light_val, 0);
            ADD_VERTEX_P(x0, y0, z1,  0,0,1, u_max, v_max, light_val, 0);
            ADD_VERTEX_P(x0, y1, z1,  0,0,1, u_max, v_min, light_val, 100);
            
            ADD_VERTEX_P(x1, y0, z0,  0,0,1, u_min, v_max, light_val, 0);
            ADD_VERTEX_P(x0, y1, z1,  0,0,1, u_max, v_min, light_val, 100);
            ADD_VERTEX_P(x1, y1, z0,  0,0,1, u_min, v_min, light_val, 100);
        }
        
        #undef ADD_VERTEX_P
        

        
        Mesh mesh = { 0 };
        // mesh.vertexCount = ... set below
        // Raylib GenMesh... NO. We must fill Mesh struct directly like in build_chunk_mesh.
        // But initializing `Mesh mesh = {0}` works.
        
        // Fill data
        mesh.vertexCount = vertex_count;
        mesh.triangleCount = vertex_count / 3;
        mesh.vertices = vertices;
        mesh.normals = normals;
        mesh.texcoords = texcoords;
        mesh.colors = colors;
        
        // Silence "Mesh uploaded successfully" INFO log
        SetTraceLogLevel(LOG_WARNING);
        UploadMesh(&mesh, false);
        SetTraceLogLevel(LOG_INFO);
        
        c->plant_mesh = mesh;
        c->plant_model = LoadModelFromMesh(mesh);
        
        c->plant_model.materials[0].shader = get_shader_lighting();
        c->plant_model.materials[0].maps[MATERIAL_MAP_DIFFUSE].texture = get_tex_grass(); // Use grass texture again
        
        c->plant_mesh_built = 1;
    }
}
